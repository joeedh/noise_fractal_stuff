<!DOCTYPE html>
<html>
<head><title>Newton Fractal Explorer</title>
  <script type="application/javascript" src="js/require.js">
  </script>
  <script type="application/x-fragment-shader" id="fragment">
uniform vec2 iRes;
uniform float aspect;
uniform float SLIDERS[12];
uniform float T;
uniform float enableAccum;
uniform float filterWidth;
uniform float sharpness;

uniform sampler2D rgba;

#define M_PI 3.141592654

vec2 cmul(vec2 a, vec2 b) {
    return vec2(
        a[0]*b[0] - a[1]*b[1],
        a[0]*b[1] + b[0]*a[1]
    );
}

vec2 fsample(vec2 z, vec2 p) {
    const float d = 1.0;
    //(z-1)(z+1)(z-p)
    vec2 a = z - vec2(d, 0.0);
    vec2 b = z + vec2(d, 0.0);
    vec2 c = z - p;
    return cmul(cmul(a, b), c);
}

//#define STEPS 400

float tent(float f) {
    return 1.0 - abs(fract(f)-0.5)*2.0;
}

vec2 tent(vec2 p) {
    return vec2(tent(p.x), tent(p.y));
}

float length2(vec2 p) {
  float sf = dot(p, p), f = sf < 1.0 ? sf*10.5 : sf*0.25;
  
  if (isnan(sf)) {
    return 0.01;
  }
  
  f = (f*f + 3.0*sf) / (3.0*f + sf/f);
  f = (f*f + 3.0*sf) / (3.0*f + sf/f);
  //f = (f + sf/f)*0.5;
 
  return f;
}

float run(vec2 uv) {
    uv = uv/iRes*2.0 - 1.0;
    uv.x *= aspect;
    
    uv.x += SLIDERS[5];
    uv.y += SLIDERS[6];//+0.5*SLIDERS[4];

    uv *= SLIDERS[4];

    vec2 seed;
    
    vec2 dr, di;
    float f = 0.0;
    float dist = 0.0;
    vec2 z;
    
    vec2 startuv = uv;
    
    float tm = 0.0;
    float tm2 = 0.0;
    
#ifndef SIMPLE_MODE
  seed = uv;
#else
    seed = vec2(SLIDERS[11], 0.0); //0.4132432);
    //seed = vec2(pow(SLIDERS[11], uv[0]*0.5+0.5), pow(SLIDERS[11], uv[1]*0.5+0.5));
#endif

    tm = SLIDERS[1];
    //tm = pow(tm, 1.0/1.0);
    float toff = pow(tm, 0.25);
    
    for (int i=0; i<STEPS; i++) {
        //float toff = sin(T*0.1);
        //toff = 0.75;
        z = cmul(uv, vec2(0.333333 + tm*0.5, 0.0 + tm)); //0.85*toff));
        
        vec2 a = fsample(z, seed);

#if 0 //finite differences
        float df = 0.0002;

        vec2 b = fsample(z+vec2(df, 0.0), seed);
        vec2 c = fsample(z+vec2(0.0, df), seed);
        
        dr = (b - a) / df;
        di = (c - a) / df;
#else //anayltical derivatives
        vec2 p = seed;
        float zx = z[0], zy = z[1];
        float px = p[0], py = p[1];
        
        /* heissan matrices
        on factor;
        off period;
        
        drx := -(2.0*((px-zx)*zx-(py-zy)*zy)+zy*zy+1.0-zx*zx);
        dry := -2.0*((py-zy-zy)*zx+(px-zx)*zy);
      
        dix := 2.0*((py-zy-zy)*zx+(px-zx)*zy);
        diy := -(2.0*((px-zx)*zx-(py-zy)*zy)+zy*zy+1.0-zx*zx);
        
        rxzx := df(drx, zx);
        rxzy := df(drx, zy);
        ryzx := df(dry, zx);
        ryzy := df(dry, zy);

        ixzx := df(dix, zx);
        ixzy := df(dix, zy);
        iyzx := df(diy, zx);
        iyzy := df(diy, zy);
        
        rxm := mat((rxzx*rxzx, rxzy*rxzx),
            (rxzy*rxzx, rxzy*rxzy));
        rym := mat((ryzx*ryzx, ryzy*ryzx),
            (ryzy*ryzx, ryzy*ryzy));
        ixm := mat((ixzx*ixzx, ixzy*ixzx),
            (ixzy*ixzx, ixzy*ixzy));
        iym := mat((iyzx*iyzx, iyzy*iyzx),
            (iyzy*iyzx, iyzy*iyzy));
        
        on fort;
        rxm;
        rym;
        ixm;
        iym;
        off fort;
        
        */
        dr.x = -(2.0*((px-zx)*zx-(py-zy)*zy)+zy*zy+1.0-zx*zx);
        dr.y = -2.0*((py-zy-zy)*zx+(px-zx)*zy);
      
        di.x = 2.0*((py-zy-zy)*zx+(px-zx)*zy);
        di.y = -(2.0*((px-zx)*zx-(py-zy)*zy)+zy*zy+1.0-zx*zx);
#endif

#if 1

 mat2 rxm = mat2( vec2(4.0*(px-3.0*zx)*(px-3.0*zx),-4.0*(px-3.0*zx)*(py-3.0*zy)),
                 vec2(-4.0*(px-3.0*zx)*(py-3.0*zy), 4.0*(py-3.0*zy)*(py-3.0*zy)));

 mat2 rym = mat2(vec2(4.0*(py-3.0*zy)*(py-3.0*zy), 4.0*(px-3.0*zx)*(py-3.0*zy)),
                  vec2(4.0*(px-3.0*zx)*(py-3.0*zy), 4.0*(px-3.0*zx)*(px-3.0*zx)));

  mat2 ixm = mat2(vec2(4.0*(py-3.0*zy)*(py-3.0*zy), 4.0*(px-3.0*zx)*(py-3.0*zy)),
                  vec2(4.0*(px-3.0*zx)*(py-3.0*zy), 4.0*(px-3.0*zx)*(px-3.0*zx)));

  mat2 iym = mat2(vec2(4.0*(px-3.0*zx)*(px-3.0*zx), -4.0*(px-3.0*zx)*(py-3.0*zy)),
                  vec2(-4.0*(px-3.0*zx)*(py-3.0*zy), 4.0*(py-3.0*zy)*(py-3.0*zy))); 
#endif
        mat2 m = mat2(dr, di);
        
        m = inverse(m);
        
        vec2 off = -m * a;
        
#if 0
        if (i % 2 == 1) {
          off.x *= -1.0;
        } else {
          off.y *= -1.0;
        }
#endif
        
        off.xy += vec2(-off.y, off.x)*SLIDERS[10];
        
        dist += 2.0*length(off) / (SLIDERS[9] + length(iym*rxm * off));
        //dist += 0.12 / (0.1 + length(rym*off));
        
        //dist += (determinant(rxm) + determinant(rym) + determinant(ixm) + determinant(iym))*1000.0;
        //dist += determinant(rxm*rym*ixm*iym)*100000.0;
        //dist += (abs(off[0]) + abs(off[1]))*0.5;
        //dist += max(abs(off[0]), abs(off[1]));
        
        if (i > int(SLIDERS[0])) {
            break;
        }
        
        uv += off;
    }
    
    float d1 = length(uv - vec2(-1.0, 0.0));
    float d2 = length(uv - vec2(1.0, 0.0));
    float d3 = length(uv - seed);
    
    //find closest root shade
    f = d1 < d2 ? 1.0 : 0.75;
    f = d3 < d2 && d3 < d1 ? 0.5 : f;
    
    float tfac = pow(1.0 - toff, 0.25);
    float dfract;
    //dfract = min(dist*0.0025, 1.0);
    dfract = tent(dist*0.004);
    f = sqrt(dfract)*0.5;
    //f = (dfract + f)*0.5;
    //f = sqrt(dfract*f)*0.5;
    
    //f = dfract;
    //f *= f;
    
    //f = pow(f * (1.0-dfract), 0.4);
    //f = mix(pow(dfract, 0.25), dfract, 0.5);
    //f = dfract*dfract*(3.0-2.0*dfract);
    
    //f = f*f*(3.0-2.0*f);
    //f = fract(length(fsample(z, uv)));    
    //f = fract(length(uv - startuv));
    
    return f;
}

float hash(float seed) {
    float f = fract(sin(seed*13.0) + seed*8.9);
    //float f = fract(seed);
    return fract(1.0 / (f*0.0001 + 0.0000001));
}

float hash2(vec2 p) {
    p *= 1.0;
    float a = 0.445325234;// + 0.01*fract(T*0.1);
    
    p += tent(p*4.1234)*2.0 - 1.0;
    
    float f = p[0]*a + p[1]/a;
    
    f += T*100.0;
    
    return hash(f);
    return fract(f);
}

float uhash2(vec2 p) {
    float f;
    
    f = hash2(p);
    //return f;
    f += hash2(p + vec2(2.234, 0.63));
    f += hash2(p + vec2(-10.8, 0.95));
    
    //f = pow(f, 1.0/3.0);
    f /= 3.0;
    
    //f *= f*f*f*f;
    
    return f*2.0 - 1.0;
}

float mainImage( in vec2 fragCoord, out float w) {
    vec2 uv = fragCoord;

#ifdef PER_PIXEL_RANDOM
    float dx = uhash2(uv);
    float dy = uhash2(-uv + 2.43223);
#else
    float dx = uhash2(vec2(0.,0.));
    float dy = uhash2(-vec2(0.,0.) + 2.432);
    
    //dx = fract(T*100.0)*2.0 - 1.0;
    //dy = fract(T*100.0+0.45)*2.0 - 1.0;
#endif    
    //fragColor = vec4(dx, dy, 0.0, 1.0);
    //return;
    
    //apply some sharpening in the monte carlo distribution,
    //converges slowly.  sharpening also happens in final accumulation
    //step.
#ifdef USE_SHARPNESS
    float filterw = filterWidth*2.0;
    
    w = max(1.0 - (length(vec2(dx, dy)) / sqrt(2.0)), 0.0);
    //w = w*w*(3.0 - 2.0*w);
    float eps = 0.3 + sharpness*0.2;
    w = w*w*(1.0 + eps) - eps*1.5;
#else    
    float filterw = filterWidth;
    //w = max(1.0 - length(vec2(dx, dy)) / sqrt(2.0), 0.0) + 0.25;
    //w = w*w*(3.0 - 2.0*w);
    //w = w*w;
    w = 1.0;
#endif

    uv += filterw*vec2(dx, dy);
    
#if 0
    float w = filterw;
    float f = run(uv) * 2.0
            + run(uv + vec2(-w, -w))
            + run(uv + vec2(-w, w))
            + run(uv + vec2(w, w))
            + run(uv + vec2(w, -w));
    f *= 1.0 / (4.0 + 2.0);
#else
    float f = run(uv);
#endif    
    // Output to screen

    vec4 color = vec4(f, f, f, 1.0);
    
    /*
    f = uhash2(uv)*0.5 + 0.5;
    fragColor = vec4(f, f, f, 1.0);//*/

    //if (iMouse.z < 0.0) {
      //fragColor.r += old.r;
      //fragColor.g = old.b;
      //fragColor.b = f;
      //fragColor.a += old.a;
    //}
    
    //XXX
#if 0
    f = hash2(fragCoord.xy); //iResolution.xy);
#endif
    return f;
}

vec4 shader(float ix, float iy) {
  float w;
  float f = mainImage(vec2(ix, iy), w);
  
  vec2 uv = vec2(ix, iy) / iRes;
  vec4 color;
  
#if 0 //defined(OLD_GRADIENT) && !defined(NO_GRADIENT)
  f = mix(f*1.5, pow(f, 1.0 / SLIDERS[2]), 0.5);
  f = tent(f*SLIDERS[7]+0.5);
  
  float off = SLIDERS[3];
  float f2 = f*pow(off*0.05, 0.25) + off + 0.45;
  
  color.r = tent(f2);
  color.g = tent(f2*2.0+0.234);
  color.b = tent(f2*3.0+0.7324);
  color.a = w;
  
  color.rgb = normalize(color.rgb);
  //color.b *= 0.1;
  color.rgb *= f*1.5*SLIDERS[8];
  //color.rgb = vec3(f, f, f)*SLIDERS[8]*1.5;
  
  color.rgb *= w;
  
#else
  color = vec4(f, f, f, 1.0) * w;
#endif

  //return color; //XXX
  
  vec4 old = texture(rgba, uv);
  return color + old*enableAccum;
}


  </script>
  <script type="application/javascript">
    'use strict';

    let _jitter = new Array(512);
    
    for (let i=0; i<_jitter.length; i++) {
      _jitter[i] = Math.random();
    }
    
    Math.fract = f => f - Math.floor(f);
    Math.tent = f => 1.0 - Math.abs(Math.fract(f) - 0.5)*2.0;

    window.DEBUG = {};

    require.config({
      baseUrl: "./js/"
    });

    let SLIDER_NAMES = [
      {name: "steps", integer: true, range: [5, 955]}, //0
      {name: "offset", range: [-5.0, 5.0]}, //1
      {name: "gain", range:[0.001, 1000], speed: 4.0, exp: 2.0},  //2
      "color", //3
      {name: "scale", range: [0.001, 1000000.0]}, //4
      "x",  //5
      "y",  //6
      {name: "colorscale", default: 1.0},//7
      {name: "brightness", range: [0.001, 10.0], default: 1.0}, //8
      {name: "hoff", range: [0.0001, 10.0], default: 0.15}, //9
      {name: "poff", range: [-8.0, 4.0], speed : 0.1, exp : 1.0, default: 0.0}, //10
      {name: "simple", default: 0.0, range : [-44.0, 44.0]}
    ];

    const LOCAL_STORAGE_KEY = "s_newton_fractal";

    //let SLIDERS;
    window.SLIDERS = null;

    window.T = 0;

    let _base_preset = {
      "config": {
        "SLIDERS"            : [
          95.84821428571426,
          0.9767857142857139,
          0.18750000000000028,
          1.703214318411691,
          0.5,
          0,
          0,
          5.864285714285717,
          1,
          0.2,
          0
        ],
        "PRESET"             : "Preset",
        "NO_GRADIENT"        : false,
        "SHOW_SLIDERS"       : true,
        "SHARPNESS"          : 0.351,
        "USE_SHARPNESS"      : true,
        "USE_MONTY_SHARPNESS": false,
        "FILTER_WIDTH"       : 1.2770000000000001,
        "PER_PIXEL_RANDOM"   : true,
        "MAX_SAMPLES"        : 264,
        "OLD_GRADIENT"       : true
      },
      "name"  : "Preset"
    }

    window.SLIDERS = [55, 0.0, 1.0, 1.0, 0.25, 0.0, 0.0, 1.0, 1.0, 0.2, 0.0, 0.0];

    SLIDERS = [95.84821428571426, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 0.25, 0, 0,
               5.864285714285717, 1, 0.2, 0.0];

    let builtin_presets = [];
    let name_gen = 1;

    function add_preset(sliders, config_override = {}, name) {
      if (typeof name === "object") {
        console.error(name);
        throw new Error("invalid name " + name);
      }
      if (name === undefined) {
        name = "Builtin " + (name_gen++);
      }

      sliders = sliders.concat([]);
      while (sliders.length < SLIDER_NAMES.length) {
        let def = SLIDER_NAMES[sliders.length];

        if (typeof def === "object" && "default" in def) {
          sliders.push(def.default);
        } else {
          sliders.push(0.0);
        }
      }

      //copy
      let ret = JSON.parse(JSON.stringify(_base_preset));

      Object.assign(ret.config, config_override);
      
      ret.config.SLIDERS = sliders;
      ret.builtin = true;
      ret.name = name;

      builtin_presets.push(ret);

      return ret;
    }

    /*1*/
    add_preset([218.08035714285708, 0.5357142857142856, 0.18750000000000028, 1.703214318411691, 7.164838838374205,
                1.7176390515946043, -6.14911515900138, 5.896428571428575, 1.5813571428571425, 0.31795714285714344,
                0.39285714285714257]);

    /*2*/
    add_preset([218.08035714285708, 0.5357142857142856, 0.18750000000000028, 1.703214318411691, 1672.9778006948582,
                533.1913796170645, -1369.4896222264827, 5.896428571428575, 1.5813571428571425, 0.31795714285714344,
                0.39285714285714257]);

    /*3*/
    add_preset([141.02455357142856, 0.5357142857142856, 0.18750000000000028, 1.703214318411691, 72.5141670544459,
                -41.26995147236086, -56.679514207268404, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                0.39285714285714257]);

    /*4*/
    add_preset([505.49107142857144, 0.40678571428571525, 0.18750000000000028, 1.703214318411691, 23.863339902760213,
                8.208694404452228, -7.3150383917304715, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                0.9635714122227251]);

    /*5*/
    add_preset([505.49107142857144, 0.40678571428571525, 0.18750000000000028, 1.703214318411691, 218.86902540241812,
                225.16709215347998, 46.63325655830616, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                0.9635714122227251]);

    /*6*/
    add_preset([505.49107142857144, 0.40678571428571525, 0.18750000000000028, 1.703214318411691, 296.81855972779033,
                45.814179901364675, -16.096686199735252, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                0.9635714122227251]);

    /*7*/
    add_preset([148.70535714285714, 0.40937500000000104, 0.18750000000000028, 1.703214318411691, 2135.64031675207,
                290.52889138853396, -18.46276812938317, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                0.9635714122227251]);

    /*8*/
    add_preset([138.79464285714286, 0.0683035714285724, 0.18750000000000028, 1.703214318411691, 3453.5449087279094,
                1313.7115428892575, -1038.5758274262691, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                1.7849999836512958]);

    /*9*/
    add_preset([138.79464285714286, 0.0683035714285724, 0.18750000000000028, 1.703214318411691, 23991.034608322116,
                9127.225043302906, -7213.735604221987, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                1.7849999836512958]);

    /*10*/
    add_preset([138.79464285714286, 0.04312496730259482, 0.18750000000000028, 1.703214318411691, 194.12303243331695,
                71.45118050162856, -8.146172431070598, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                2.676071412222723]);

    /*11*/
    add_preset([138.79464285714286, 0.04312496730259482, 0.18750000000000028, 1.703214318411691, 26.44442281037317,
                -6.263647476679338, -11.964067062458309, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                2.676071412222723]);

    /*12*/
    add_preset([138.79464285714286, 0.04312496730259482, 0.18750000000000028, 1.703214318411691, 207.3423491945681,
                76.18185798687021, -8.431233545247746, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                2.676071412222723]);

    /*13*/
    add_preset([75.36607142857143, 0, 0.18750000000000028, 1.703214318411691, 51.20875171284011, -19.703738146334267,
                32.230303095243954, 5.896428571428575, 1.5813571428571425, 0.13581428571428636, 3.256428555079866]);

    /*14*/
    add_preset([214.1160714285714, 0.5017857142857144, 0.18750000000000028, 1.703214318411691, 6.865195590268386,
                6.856305835136788, -5.747427139229283, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                0.7875000000000004]);

    /*15*/
    add_preset([214.1160714285714, 0.5017857142857144, 0.18750000000000028, 1.703214318411691, 328.9223418483428,
                377.3390277404351, -283.60260388699226, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                0.7875000000000004]);

    /*16*/
    add_preset([133.83928571428567, 0.6089285714285713, 0.18750000000000028, 1.7085714612688336, 1784.1720750183626,
                2770.557072404935, -800.4963652768986, 9.836785643441342, 2.49635707746233, 2.250457164655413, 0.35]);

    /*17*/
    add_preset([108.56696428571428, 0.2925000217982699, 0.18750000000000028, 1.703214318411691, 4441.224981339366,
                -1650.7526499113544, 1842.54234040089, 5.128571428571431, 1.294642857142856, 0.20902857142857142,
                1.1618749891008655]);

    /*18*/
    add_preset([108.56696428571428, 0.2925000217982699, 0.18750000000000028, 1.703214318411691, 67.97935479723843,
                -96.45928625401233, -40.22508843623597, 5.128571428571431, 1.294642857142856, 0.09474285714285718,
                1.165714175360545]);

    /*19*/
    add_preset([467.33486679622115, 0.30321430751255557, 0.18750000000000028, 1.703214318411691, 12.278254507230557,
                16.56580431682912, -9.10549299909097, 5.128571428571431, 1.294642857142856, 0.09474285714285718,
                1.165714175360545]);

    /*20*/
    add_preset([467.33486679622115, 0.30321430751255557, 0.18750000000000028, 1.703214318411691, 156.65484368428395,
                218.53097488071762, -119.64752062325061, 5.128571428571431, 1.294642857142856, 0.09474285714285718,
                1.165714175360545]);

    /*21*/
    add_preset([308.7634382247926, 0.6032143075125556, 0.18750000000000028, 1.703214318411691, 12.751380923729673,
                -19.901461903740064, 49.33473848557248, 5.128571428571431, 1.294642857142856, 1.244742884390695,
                0.6207141753605441]);

    /*22*/
    add_preset([150.19196428571425, 0.0683035714285724, 0.18750000000000028, 1.703214318411691, 42.37026304090599,
                82.89648098820756, 9.405966216662012, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                1.7849999836512958], {USE_SHARPNESS: false});

    /*23*/
    add_preset([150.19196428571425, 0.0683035714285724, 0.18750000000000028, 1.703214318411691, 1451.9367815845,
                2428.6767270129744, -1801.45262137192, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                1.7849999836512958], {
      USE_SHARPNESS: false,
      OLD_GRADIENT : false,
      GRADIENT     : {
        "stops": [{"color": [0, 0, 0, 1], "t": 0, "flag": 0, "type": 2, "id": 1},
                  {"color": [0, 0, 0, 1], "t": 0, "flag": 0, "type": 2, "id": 1},
                  {"color": [0, 0, 0, 1], "t": 0, "flag": 0, "type": 2, "id": 1},
                  {"color": [0, 0, 0, 1], "t": 0, "flag": 0, "type": 2, "id": 1},
                  {"color": [0, 0, 0, 1], "t": 0, "flag": 0, "type": 2, "id": 1},
                  {"color": [0, 0, 0, 1], "t": 0, "flag": 0, "type": 2, "id": 8},
                  {"color": [0.4627449933220359, 0, 0, 1], "t": 0.17176756566884566, "flag": 0, "type": 2, "id": 15}, {
            "color": [0.7471753318878134, 0.3375035180846987, 0.18892763739834262, 1], "t": 0.2840136054421769,
            "flag" : 0, "type": 2, "id": 19
          }, {
            "color": [1, 0.6375039166945187, 0.3568617876838235, 1], "t": 0.44047652783037056, "flag": 0, "type": 2,
            "id"   : 13
          }, {"color": [0.41372516108494184, 0, 0, 1], "t": 0.5884346475406569, "flag": 0, "type": 2, "id": 14}, {
            "color": [0.17647058823529416, 0.009688539076016434, 0.17647058823529416, 1], "t": 0.7465988470583546,
            "flag" : 0, "type": 2, "id": 17
          }, {"color": [0, 0, 0, 1], "t": 0.9931968637064201, "flag": 0, "type": 2, "id": 10},
                  {"color": [1, 1, 1, 1], "t": 1, "flag": 0, "type": 2, "id": 2},
                  {"color": [1, 1, 1, 1], "t": 1, "flag": 0, "type": 2, "id": 2},
                  {"color": [1, 1, 1, 1], "t": 1, "flag": 0, "type": 2, "id": 2},
                  {"color": [1, 1, 1, 1], "t": 1, "flag": 0, "type": 2, "id": 2},
                  {"color": [1, 1, 1, 1], "t": 1, "flag": 0, "type": 2, "id": 2}], "brightness": -0.43382961347599663,
        "contrast": 7.510392840241535, "postBrightness": 0.03818634889121153, "postContrast": 1.3697821511972195,
        "active": 19, "highlight": 14, "version": 0.1, "idgen": 20, "satOffset": 1, "hueOffset": 0
      }
    });

    /*24*/
    add_preset([112.54464285714286, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 213.8822849029874,
                273.9839237749515, 19.300310122408185, 6.596428571428576, 1, 0.2]);
    /*25*/
    add_preset([168.13391208648684, 0.9920535714285709, 0.18750000000000028, 1.703214318411691, 6211.793717195564,
                -7806.111585297848, -77.8748106180099, 6.596428571428576, 0.7017857142857142, 0.2]);

    /*26*/
    add_preset([122.85714285714286, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 173.81324375172892,
                -254.0360532896516, -275.7863544203954, 3.037500000000006, 0.897499990463256, 0.07688571428571428]);

    /*27*/
    add_preset([165.55357142857142, 1.4929464285714282, 0.18750000000000028, 1.703214318411691, 44.09879760618848,
                25.25295436609055, 1.6766015727644565, 5.864285714285717, 1, 0.10545714285714287]);
    /*28*/
    add_preset([165.55357142857142, 1.848303571428571, 0.18750000000000028, 1.703214318411691, 32.28700277258628,
                -44.62170557975985, 7.766630577419785, 5.864285714285717, 1, 0.10545714285714287]);

    /*29*/
    add_preset([218.08035714285708, 0.5357142857142856, 0.18750000000000028, 1.703214318411691, 74.4492995164945,
                69.31136391025414, -104.23912139341301, 5.896428571428575, 1.5813571428571425, 0.2590285714285714,
                0.39285714285714257]);
    /*30*/
    add_preset([218.08035714285708, 0.5357142857142856, 0.18750000000000028, 1.703214318411691, 90.61091827209286,
                36.44740342885476, -71.87469545099766, 5.896428571428575, 1.5813571428571425, 0.31795714285714344,
                0.39285714285714257]);

    /*31*/
    add_preset([142.9910714285717, 1.0124999999999995, 2.4535714285714283, 6.747142857142873, 664.1731807714872,
                1207.3880358051968, -1469.7663367402351, 4.500000000000001, 0.944642857142858, 0.2]);

    /*32*/
    add_preset([143.9732142857144, 1.024999999, 0.18750000000000028, 1.703214318411691, 5.2441348995084605,
                4.492312812495602, -7.554459806904133, 4.414285714285716, 1.3706428571428535, 0.2]);

    /*33*/
    add_preset([234.8214285714288, 1.0124999999999995, 2.4535714285714283, 6.747142857142873, 345.9292832795721,
                693.1711001944254, -867.729561420194, 4.500000000000001, 0.944642857142858, 0.2]);
    /*34*/
    add_preset([143.9732142857144, 1.0125, 0.18750000000000028, 1.703214318411691, 34.28756782192009, 26.63696481081162,
                -51.10978608361746, 5.864285714285717, 1, 0.2]);

    /*35*/
    add_preset([210.75892857142856, 1.0125, 0.18750000000000028, 1.703214318411691, 1909.8517115074794,
                -1812.4628747289303, -555.0500970832212, 5.864285714285717, 1]);

    /*36*/
    add_preset([210.75892857142856, 0.9946428571428572, 0.18750000000000028, 1.703214318411691, 2.905224824824826,
                2.1884738665642733, 0.14429498021302922, 5.864285714285717, 1, 0.2]);

    /*37*/
    add_preset([210.75892857142856, 0.9946428571428572, 0.18750000000000028, 1.703214318411691, 1, 0, 0,
                5.864285714285717, 1, 0.2]);
    /*38*/
    add_preset([95.84821428571426, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 2524.560176697589,
                1002.7293396666025, -1755.8241494145964, 5.864285714285717, 1, 0.2]);

    /*39*/
    add_preset([270.2232142857143, 0.9328571864536834, 0.18750000000000028, 1.703214318411691, 8.649181855003139,
                11.47052280902922, -9.091417899750033, 5.455357142857149, 1, 1.5115286150251115,
                0.04910713195800781], {USE_SHARPNESS: false});

    /*40*/
    add_preset([270.2232142857143, 0.9328571864536834, 0.18750000000000028, 1.703214318411691, 13.106962994885548,
                55.718415177693956, -28.181353985371594, 5.455357142857149, 1, 1.5115286150251115,
                0.10339283534458706], {USE_SHARPNESS: false});

    /*41*/
    add_preset([503.75669642857144, 0.9328571864536834, 0.18750000000000028, 1.703214318411691, 11.31995525789419,
                43.10655833386126, -1.0418274337717575, 5.455357142857149, 1, 3.8918857578822554,
                0.04910713195800781], {USE_SHARPNESS: false});

    /*42*/
    add_preset([119.71651785714285, 1.0482142857142853, 0.18750000000000028, 1.703214318411691, 309.54259410956604,
                257.4288420732536, 119.70101945738558, 5.896428571428575, 1.5813571428571425, 0.13581428571428636,
                0.39285714285714257]);
    /*43*/
    add_preset([109.06249999999999, 0.2428571428571429, 0.18750000000000028, 1.703214318411691, 159.54514568103218,
                -253.00131536143985, -322.60301727005833, 3.827142824445457, 1.099214285714285, 0.03760000000000001,
                0.9000000136239187], {SHARPNESS: 0.3});
    /*44*/
    add_preset([109.06249999999999, 0.2428571428571429, 0.18750000000000028, 1.703214318411691, 6.703310339950971,
                10.908440557939901, 2.4633738224672355, 3.827142824445457, 1.099214285714285, 0.03760000000000001,
                0.9000000136239187], {SHARPNESS: 0.3});
    /*45*/
    add_preset([109.06249999999999, 0.2428571428571429, 0.18750000000000028, 1.703214318411691, 192.1175703493885,
                -100.25254378377208, 24.945728056306706, 3.827142824445457, 1.099214285714285, 0.03760000000000001,
                0.9000000136239187]);
    /*46*/
    add_preset([95.84821428571426, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 1778.7066386575025,
                1026.853704132181, -1547.7991034680997, 5.864285714285717, 1, 0.2, 0]);
    /*47*/
    add_preset([95.84821428571426, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 18.91000271702588,
                31.238553286366578, 11.662676169032705, 5.864285714285717, 1, 0.2,
                0.01714275905064174], {SHARPNESS: 0.63});
    /*48*/
    add_preset([95.84821428571426, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 10389.442492149445,
                -7124.325985607432, 813.060213555674, 5.864285714285717, 1, 0.2, 0.01714275905064174]);
    /*49*/
    add_preset([95.84821428571426, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 2014.0230659877236,
                -1229.2860647893015, 707.6984584916173, 5.864285714285717, 1, 0.2, 0.01714275905064174]);
    
    /*50*/
    add_preset( [318.92187499999994, 0.6357142857142852, 0.18750000000000028, 1.703214318411691, 19.242563138503474, 6.799362912521806, -4.324739157680995, 8.105357142857146, 1, 0.2, 0.6957142857142852]);
    
    /*51*/
    add_preset( [318.92187499999994, 0.6357142857142852, 0.18750000000000028, 1.703214318411691, 6220.381053904395, 280.2829483700826, -823.7451013254885, 15.887499999999983, 1, 0.2, 0.6957142857142852]);
    
    /*52*/
    add_preset( [200, 0, 0.18750000000000028, 1.703214318411691, 146.1518596835663, 142.2331706484634, -149.28705371005233, 7.5, 1.5813571428571425, 1.1822428571428578, 3.256428555079866]);
    
    /*53*/
    add_preset([200, 0, 0.18750000000000028, 1.703214318411691, 3765.0846891962915, 7954.318605034797, -1103.335113613411, 7, 1.5813571428571425, 1.1822428571428578, 3.256428555079866],
    {SHARPNESS:0.3});
    
    /*54*/
    add_preset([95.84821428571426, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 52.26290868999668, 8.972127470831875, -32.72613779824658, 4, 1, 0.2, 0.013214318411690863], {SHARPNESS:0.45});
    
    /*55*/
    add_preset([250, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 853.9568259442332, -1110.3690303045883, 213.09594358096737, 13, 1.532857022966657, 1.077142884050096, 0.3882143238612584]);
    
    /*56*/
    add_preset([250, 0.9696428571428568, 0.18750000000000028, 1.703214318411691, 1607.5649796795967, -850.1490163745307, -1166.5585118372478, 2.5, 1.2946427481515075, 0.0001, 0.010714285714285706], {SHARPNESS : 0.221});
    
    /*57*/
    add_preset([225, 0.9696428789411269, 0.18750000000000028, 1.703214318411691, 1004.2244543593195, -405.2274999997285, -410.17363403908496, 2.48, 1.1439284460885186, 0.27, 0.02], {SHARPNESS : 0.25});
    
    /*58*/
    add_preset([160, 0.9696428789411269, 0.2, 1.6785, 0.25, 0, 0, 2.48, 1.4753570011683876, 0.27, 0.01795877012234775], {SHARPNESS : 0.377});
    
    /*59*/
    add_preset([95.84821428571426, 0.9767857142857139, 0.18750000000000028, 1.703214318411691, 438.36179372577266, 170.80912961471446, -177.89833300007095, 5.864285714285717, 1, 0.2, 0, 0], {SHARPNESS : 0.2});
    
    /*60*/
    add_preset([287.12499999999994, 0.8910714285714283, 0.18750000000000028, 1.703214318411691, 3.4763170848618725, -3.605497881548915, -3.8177478194538197, 6.617857142857145, 1.3142857142857134, 1.0017857142857143, 0.08571428571428569, 0], {SHARPNESS : 0.431});
    
    /*61*/
    add_preset([287.12499999999994, 0.8821428571428569, 0.18750000000000028, 1.703214318411691, 26.513821883762738, 22.846434001367058, -61.54579238776537, 6.617857142857145, 1.3142857142857134, 2.4535714285714283, 0.09464285714285707, 0], {SHARPNESS: 0.431});
    
    /*62*/
    add_preset([287.12499999999994, 0.7859821428571429, 0.18750000000000028, 1.703214318411691, 1.9563423004928795, -5.8027776851033765, -2.560999790267362, 6.617857142857145, 1.3142857142857134, 2.4535714285714283, 0.19080357142857138, 0], {SHARPNESS: 0.431});
    
    /*63*/
    add_preset([211.0602678571429, 0.8894642857142852, 0.18750000000000028, 1.703214318411691, 75.37105961667172, 117.45725492687764, 73.39023495668937, 5.864285714285717, 1, 0.2, 0.0873214285714286, 0.864375]);
    
    /*64*/
    add_preset([286.1338832037789, 1.1639285932268417, 0.18750000000000028, 1.703214318411691, 11.84876379511491, 35.54156494939142, 38.043634174965575, 5.864285714285717, 1, 0.2, -0.1871428789411278, 0]);
    
    /*65*/
    add_preset([258.7144066946847, 0.15392857142857166, 0.18750000000000028, 1.703214318411691, 5747.520786846519, -11398.765261381719, -9706.141988757432, 5.864285714285717, 1, 3.3299999168940957, 1.2500000381469727, 0]);
    
    /*66*/
    add_preset([180.966598374503, 0.13017857142857145, 0.31374994414193214, 1.6287500653948086, 4099.494164078572, -5857.649366838774, -10536.113391689685, 7.976250233820484, 1.2126786163236403, 3.4942072362448533, 1.3180358941214176, 1.5685713733945532]);
    
    /*67*/
    add_preset([395.5648126602172, 0, 3.3695163236183876, 1.7433928353445867, 31.506592803940187, 45.64621398279176, -41.33984283418777, 7.984821722337154, 1.0612500666933393, 4.879921412967788, 2.8441963890620645, 5]);
    
    /*68*/
    add_preset([176.2052548272269, -0.8600002356937966, 0.40850889087315906, 1.6632142203194769, 2935.456942779426, 3024.7767522313793, -6285.370519082118, 5.864285714285717, 1, 2.050000027247838, 1.7975001171657012, 0]);
    
    /*69*/
    add_preset([176.2052548272269, -1.167321664265228, 4.636846288410305, 1.6589282989501966, 32.885110031407805, -11.837003996284313, -6.2494779390417765, 5.864285714285717, 1, 1.4243859772273502, 2.1048215457371326, 0]);
    
    /*70*/
    add_preset([76.97098214285714, -0.786428597314015, 2.56922454819379, 1.7346426282610221, 864.7889983057948, -1583.940901039668, 749.5967115450895, 5.828571428571432, 0.9342856815883094, 1.322957393537249, 1.7239284787859197, 0]);
    
    /*71*/
    add_preset([220.14954968861173, -0.786428597314015, 2.56922454819379, 1.7346426282610221, 0.25, 0, 0, 5.828571428571432, 0.9342856815883094, 1.322957393537249, 1.7239284787859197, 0]);
    
    /*72*/
    add_preset([220.14954968861173, 0.05714285714285715, 2.56922454819379, 1.7346426282610221, 9.67200355068979, -11.401451921135585, -12.70461811183315, 5.828571428571432, 0.9342856815883094, 1.322957393537249, 1.7274999073573485, 0]);
    
    /*73*/
    add_preset([220.14954968861173, 0.05714285714285715, 2.56922454819379, 1.7346426282610221, 11.95511885074703, -16.80347190293255, -10.868380619064824, 5.828571428571432, 0.9342856815883094, 1.322957393537249, 1.7274999073573485, 0]);
    
    /*74*/
    add_preset([220.14954968861173, 0.05714285714285715, 2.56922454819379, 1.7346426282610221, 1700.6973712323888, -189.76933291923902, -1572.6693258242012, 5.828571428571432, 0.9342856815883094, 1.322957393537249, 1.7274999073573485, 0]);
    
    /*75*/
    add_preset( [220.14954968861173, 0.05714285714285715, 2.56922454819379, 1.7346426282610221, 125.31934625065814, -528.5832983729861, -326.92889293743116, 5.828571428571432, 0.9342856815883094, 1.322957393537249, 1.7274999073573485, 0]);
    
    /*76*/
    add_preset([220.14954968861173, 0.05714285714285715, 2.56922454819379, 1.7346426282610221, 4.365788905517529, 3.920088107322266, 16.931441523938783, 5.828571428571432, 0.9342856815883094, 1.322957393537249, 1.7274999073573485, 0]);
    
    /*77*/
    add_preset( [220.14954968861173, 0.05714285714285715, 2.56922454819379, 1.7346426282610221, 20.16340299885866, -84.98916755079347, -31.81380975347353, 5.828571428571432, 0.9342856815883094, 1.322957393537249, 1.7274999073573485, 0]);
    
    /*78*/
    add_preset([302.25669513429915, 0.05714285714285715, 1.9920662851350077, 1.7346426282610221, 2178.508029095749, -12357.772264903166, 8147.221115869545, 5.828571428571432, 0.9342856815883094, 3.4715289392743798, 1.7274999073573485, 0]);
    
    /*79*/
    add_preset([334.1495445115226, -0.6552299211365868, 0.018837374201005445, 4.603214086805074, 166.2833216991803, -131.12503036135598, 558.9878566864146, 5.5371428898402515, 1.052857099260603, 6.924385929543632, 2.693979727676939, -0.6914285387311663]);
    
    /*80*/
    add_preset( [334.1495445115226, 0.7242856706891784, 0.018837374201005445, 4.603214086805074, 9.383921453980847, 49.23364632974322, -23.11814993852866, 5.5371428898402515, 1.052857099260603, 1.5472429143633166, -1.6646695992606317, -0.7771426064627511]);
    
    /*81*/
    add_preset([220.14954968861173, -0.8529866071428573, 2.5746087556835806, 1.748571177891324, 65.39210390065722, -263.0924364434292, 188.34532226211226, 1.950714268003193, 1.2335714476449158, 0.9243859704153887, 1.5235266906193254, 1.7457144907542652]);
    
    /*82*/
    add_preset([220.14954968861173, -0.8529866071428573, 2.5746087556835806, 1.748571177891324, 65.39210390065722, -263.0924364434292, 188.28282226211215, 1.7060714108603352, 1.601428590502057, 0.9243859704153887, 1.5235266906193254, 1.7457144907542652]);
    
    /*83*/
    add_preset([220.14954968861173, -0.8529866071428573, 2.5746087556835806, 1.748571177891324, 3.502147300437849, -13.428322230815168, 13.527938865138731, 1.4203572068895627, 1.601428590502057, 1.6043857817241123, 1.5235266906193254, 1.7457144907542652]);
    
    /*84*/
    add_preset( [220.14954968861173, -1.5129867815290199, 2.5746087556835806, 1.748571177891324, 371.9819962205162, 37.43362247336141, 122.10784130866081, 1.4203572068895627, 1.601428590502057, 0.07438577627454487, 1.5499552606855092, 1.7457144907542652]);
    
    /*85*/
    add_preset([220.14954968861173, -1.5129867815290199, 2.5746087556835806, 1.748571177891324, 217.34008585080542, 408.58735371156575, 202.17854893444158, 1.4203572068895627, 1.601428590502057, 0.07438577627454487, 1.5499552606855092, 1.7457144907542652]);
    
    /*86*/
    add_preset([220.14954968861173, -1.5129867815290199, 2.5746087556835806, 1.748571177891324, 1682.3191624958185, 3104.1128948331293, 1423.8311668540582, 1.4203572068895627, 1.601428590502057, 0.07438577627454487, 1.5499552606855092, 1.7457144907542652]);
    
    /*87 swirl hook*/
    add_preset([220.14954968861173, -1.5129867815290199, 2.5746087556835806, 1.748571177891324, 288.61231800962776, -796.3556344982914, 796.8533012457535, 3.324642992019652, 1.601428590502057, 0.1401000163487026, 1.4572409700666134, 1.7457144907542652]);
    
    /*88*/
    add_preset([220.14954968861173, -0.8558437813350152, 22.916848204243475, 1.748571177891324, 18.11034997692541, -73.53810277511614, 46.84474649155195, 2.7846429211752755, 1.2814285959516218, 1.058671434020996, 1.457526685442242, 1.7457144907542652]);
    
    /*89*/
    add_preset( [220.14954968861173, -0.8558437813350152, 22.916848204243475, 1.748571177891324, 64.08754039509188, -178.874237416227, 233.25054701323774, 2.7846429211752755, 1.2814285959516218, 1.058671434020996, 1.457526685442242, 1.7457144907542652]);
    
    /*90*/
    add_preset([440.6852575029646, -0.8558437813350152, 22.916848204243475, 1.748571177891324, 15.246343800822169, -70.96106304804258, 35.33696628895681, 2.7846429211752755, 1.2814285959516218, 1.058671434020996, 1.457526685442242, 1.7457144907542652]);
    
    /*91*/
    add_preset([440.6852575029646, -0.8558437813350152, 22.916848204243475, 1.748571177891324, 272.310755901901, 316.90340910367877, -836.7169602492772, 2.7846429211752755, 1.2814285959516218, 1.058671434020996, 1.457526685442242, 1.7457144907542652]);
    
    /*92*/
    add_preset([193.6428584371294, -0.8801294520241896, 22.916848204243475, 1.748571177891324, 41.79655645133344, -109.90307445731945, 22.069040093450578, 2.7846429211752755, 1.2814285959516218, 1.058671434020996, 1.3719552574157703, 1.7457144907542652]);
    
    /*93*/
    add_preset([49.95535714285713, -0.9033437377384752, 22.916848204243475, 1.748571177891324, 13.30575947943466, -29.27339023082175, -25.68075774092484, 2.7846429211752755, 1.2814285959516218, 0.23295715920584542, 1.2187766827174609, 1.7457144907542652]);
    
    /*94*/
    add_preset([49.95535714285713, -0.9676294520241897, 22.916848204243475, 1.748571177891324, 21.378404060091697, -117.91318699426616, -11.9174277304477, 2.7846429211752755, 1.2814285959516218, 0.23295715920584542, 1.3717766893931815, 1.7457144907542652]);
    
    /*95*/
    add_preset( [49.95535714285713, -0.9676294520241897, 22.916848204243475, 1.748571177891324, 11.090970246420094, 33.546215509587334, 25.246376940453555, 2.7846429211752755, 1.2814285959516218, 0.23295715920584542, 1.3717766893931815, 1.7457144907542652]);
    
    /*96*/
    add_preset( [49.95535714285713, -0.9676294520241897, 22.916848204243475, 1.748571177891324, 617.1134947935625, 1897.5900322105185, 1427.0774544737012, 2.7846429211752755, 1.2814285959516218, 0.23295715920584542, 1.3717766893931815, 1.7457144907542652]);
    
    /*97*/
    add_preset([220.14954968861173, 0.043553549630301516, 2.56922454819379, 1.7346426282610221, 2353.725785804332, 3264.7025894728044, 2899.6991134279906, 5.828571428571432, 0.9342856815883094, 1.322957393537249, 1.8309284823281389, 0]);
    
    /*98*/
    add_preset( [220.14954968861173, 0.043553549630301516, 2.56922454819379, 1.7346426282610221, 211.1202899260559, 292.51388467926614, 260.16971044031186, 5.828571428571432, 0.9342856815883094, 1.322957393537249, 1.8309284823281389, 0]);
    
    /*99*/
    add_preset([220.14954968861173, 0.043553549630301516, 2.56922454819379, 1.7032140459333154, 1383.8917605347278, -2017.1181940189676, 2511.768719584845, 5.221428544180736, 0.9342856815883094, 7.590100513621739, 1.8309284823281389, 0]);
    
    /*100*/
    add_preset([57.928566251482295, 0.043553549630301516, 2.56922454819379, 1.7032140459333154, 0.25, 0, 0, 6.725714268003189, 0.9342856815883094, 7.250100524520873, 1.9523570578438876, 0]);
    
    /*101*/
    add_preset( [57.928566251482295, 0.043553549630301516, 2.56922454819379, 1.7032140459333154, 5.371475959731454, 55.84501178343102, 10.242772114025454, 6.725714268003189, 0.9342856815883094, 7.250100524520873, 1.9523570578438876, 0]);
    
    /*102*/
    add_preset([57.928566251482295, 0.08498214285714303, 2.56922454819379, 1.7032140459333154, 180.04865369527437, 27.21093830011144, -1.8460674269842645, 6.725714268003189, 0.9342856815883094, 7.250100524520873, 1.9523570578438876, 0]);
    
    /*103*/
    add_preset([57.928566251482295, 0.08498214285714303, 2.56922454819379, 1.7032140459333154, 46.857167604847604, 15.215700906702045, -55.43439504199902, 6.725714268003189, 0.9342856815883094, 7.250100524520873, 1.9523570578438876, 0]);
    
    /*104*/
    add_preset( [57.928566251482295, 0.08498214285714303, 2.56922454819379, 1.7032140459333154, 1403.036147172837, 2884.823287738094, -283.869404037833, 6.725714268003189, 0.9342856815883094, 7.250100524520873, 1.9523570578438876, 0]);
    
    /*105*/
    add_preset( [104.58035196576802, 0.08498214285714303, 2.1617298841566472, 1.7032140459333154, 48.3648561559609, 7.129132028313002, 31.172918554469597, 6.725714268003189, 0.9342856815883094, 7.250100524520873, 1.9523570578438876, 0]);
    
    /*106*/
    add_preset( [104.58035196576802, 0.08498214285714303, 2.1617298841566472, 1.7032140459333154, 3007.108158440886, 2526.0761245932595, 3263.1650746364, 6.725714268003189, 0.9342856815883094, 7.250100524520873, 1.941357045854839, 0]);
    
    /*107*/
    add_preset([104.58035196576802, 0.08498214285714303, 2.1617298841566472, 1.7032140459333154, 1649.9842242820414, 510.30619288771686, 730.5901269629959, 6.725714268003189, 0.9342856815883094, 7.250100524520873, 1.941357045854839, 0]);
    
    /*108 bunnies*/
    add_preset([104.58035196576802, 0.09551785714285733, 2.1617298841566472, 1.7032140459333154, 273.3805789373707, 118.23561001973303, -414.9322883440255, 6.725714268003189, 0.9342856815883094, 7.250100524520873, 1.941357045854839, 0]);
    
    /*109*/
    add_preset([104.58035196576802, 0.09551785714285733, 2.1617298841566472, 1.7032140459333154, 3686.673514237529, 889.5253084516826, -4635.174617286276, 8.56714289528983, 0.9342856815883094, 7.250100524520873, 1.941357045854839, 0]);
    
    /*110*/
    add_preset([150.19196428571425, 0.0683035714285724, 0.18750000000000028, 1.703214318411691, 44.639711982232555, -102.49002836513803, 28.64220577617984, 5.896428571428575, 1.5813571428571425, 0.13581428571428636, 1.7849999836512958, 0]);
    
    /*111*/
    add_preset([220.14954968861173, -1.5129867815290199, 2.5746087556835806, 1.748571177891324, 93.87610243923459, -433.5455010188993, -385.47706213937045, 3.324642992019652, 1.601428590502057, 0.1401000163487026, 1.4572409700666134, 1.7457144907542652]);
    
    /*112*/
    add_preset([273.0356236866542, -1.9301296495710143, 2.5746087556835806, 1.748571177891324, 43.103012154466384, -43.193937228134985, -26.601014864025064, 3.324642992019652, 1.601428590502057, 0.311528587777274, 1.5063838248252828, 1.7457144907542652]);
    
    /*113*/
    add_preset([273.0356236866542, -1.9301296495710143, 2.5746087556835806, 1.748571177891324, 137.9483008750693, 145.88917533527072, 57.45258540159251, 3.324642992019652, 1.601428590502057, 0.311528587777274, 1.5063838248252828, 1.7457144907542652]);
    
    /*114*/
    add_preset( [273.0356236866542, -1.9301296495710143, 2.5746087556835806, 1.748571177891324, 147.15187568967676, 264.57811562411405, -125.98617331402848, 3.324642992019652, 1.601428590502057, 0.311528587777274, 1.5063838248252828, 1.7457144907542652]);
    
    /*115*/
    add_preset([273.0356236866542, -1.9301296495710143, 2.5746087556835806, 1.748571177891324, 31.79180209443851, -62.45710272565709, 65.9417174419576, 3.324642992019652, 1.601428590502057, 0.311528587777274, 1.5063838248252828, 1.7457144907542652]);
    
    /*116*/
    add_preset([102.03564439501079, -1.8915582101004504, 2.5746087556835806, 1.748571177891324, 110.85470948637125, -23.471133389675924, -26.393447990724372, 3.324642992019652, 1.601428590502057, 0.311528587777274, 1.5120981078147835, 1.7457144907542652]);
    
    /*117*/
    add_preset( [186.00885868072504, -1.8915582101004504, 2.5746087556835806, 1.748571177891324, 206.41576078607625, 168.30491060087908, 376.94868796185625, 3.3039287430899464, 1.601428590502057, 0.09295714285714288, 1.5120981078147835, 1.7457144907542652]);
    
    /*118*/
    add_preset([186.00885868072504, -1.8915582101004504, 2.5746087556835806, 1.748571177891324, 54.1682633348115, 60.11969098820166, 28.639959300742753, 3.3039287430899464, 1.601428590502057, 0.09295714285714288, 1.5120981078147835, 1.7457144907542652]);
    
    /*119*/
    add_preset( [186.00885868072504, -1.8915582101004504, 2.5746087556835806, 1.748571177891324, 642.4057626273525, 730.5110809364097, 343.6346097624128, 3.3039287430899464, 1.601428590502057, 0.09295714285714288, 1.5120981078147835, 1.7457144907542652]);
    
    /*120*/
    add_preset([186.00885868072504, -1.8915582101004504, 2.5746087556835806, 1.748571177891324, 816.709794766772, 935.5270109640868, 439.4590993462129, 3.3039287430899464, 1.601428590502057, 0.09295714285714288, 1.5120981078147835, 1.7457144907542652]);
    
    /*121*/
    add_preset([186.00885868072504, -1.8915582101004504, 2.5746087556835806, 1.748571177891324, 377.28026983058675, 453.05927324018455, 203.5412871019587, 3.3039287430899464, 1.601428590502057, 0.09295714285714288, 1.5120981078147835, 1.7457144907542652]);
    
    /*122*/
    add_preset([186.00885868072504, -1.8915582101004504, 2.5746087556835806, 1.748571177891324, 55.45898340960511, -18.637047185164842, -10.19935763800199, 3.3039287430899464, 1.601428590502057, 0.09295714285714288, 1.5120981078147835, 1.7457144907542652], 
    {
      FILTER_WIDTH : 0.9,
    });
    
    while (SLIDERS.length < SLIDER_NAMES.length) {
      SLIDERS.push(0.0);
    }

    let DEFAULT_SLIDERS = SLIDERS.concat([]);

    var continued_fract_tmp = new Array(1024);

    function cfract_intern(n, max_steps) {
      var floor = Math.floor;
      max_steps = max_steps == undefined ? 1024 : max_steps;

      var list = continued_fract_tmp;

      for (var i = 0; i < max_steps; i++) {
        var f = floor(n)
        list[i] = f;

        n -= f;

        if (f == 0)
          break;

        n = 1.0/n
      }

      var len = i;

      var f = 1;
      for (var i = len - 1; i >= 0; i--) {
        f = list[i] + 1/f;
      }

      return f;
    }

    function cfract(f, max) {
      let sign = Math.sign(f);

      f = Math.abs(f);

      if (f < 1.0) {
        f = cfract_intern(f + 1.0, max) - 1.0;
      } else {
        f = cfract_intern(f, max);
      }

      if (max == 1) {
        f -= 1;
      }

      return f*sign;
    }

    require(["util", "webgl", "sliders", "ui", "undostack", "wasm_bin", "load_wasm"], function (util, webgl, sliders,
                                                                                                ui, undostack, wasm_bin,
                                                                                                load_wasm) {
      let wasmArgs = window.wasmArgs = {
        uv     : undefined,
        sliders: undefined,
        ready  : false
      };

      function align16(s) {
        if (s & 15) {
          s += 16 - (s & 15);
        }

        return s;
      }
      window.align16 = align16;

      let wasm = new load_wasm.Wasm();
      wasm.load(wasm_bin).then(() => {
        wasmArgs.ready = true;

        let mem = wasm.HEAP8.buffer;
        let ptr = wasm.exports.getSliderMem();

        wasmArgs.sliders = new Float64Array(mem, ptr, SLIDERS.length);

        ptr = align16(wasm.exports.getUVMem());
        wasmArgs.uv = new Float64Array(mem, ptr, 2);
        wasmArgs.simd_uv = new Float64Array(mem, ptr, 4);


        ptr = align16(wasm.exports.getOutMem());
        wasmArgs.simd_out = new Float64Array(mem, ptr, 2);

        console.log("WASM READY");
      });

      window.wasm = wasm;

      class TempStack extends Array {
        constructor(cls, count = 512) {
          super();

          this.cur = 0;

          for (let i = 0; i < 8; i++) {
            super.push(util.cachering.fromConstructor(cls, count));
          }
        }

        push() {
          this.cur++;
          return this;
        }

        pop() {
          this.cur--;
          return this;
        }

        next() {
          return this[this.cur].next();
        }

        get() {
          return this[this.cur];
        }
      }

      let vstack, mstack;

      class Vec2 {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        load(b) {
          this.x = b.x;
          this.y = b.y;

          return this;
        }

        loadXY(x, y) {
          this.x = x;
          this.y = y;
          return this;
        }

        get xy() {
          return vstack.next().loadXY(this.x, this.y);
        }

        set xy(b) {
          this.load(b);
          return this;
        }

        get yx() {
          return vstack.next().loadXY(this.y, this.x);
        }

        set yx(b) {
          this.x = b.y;
          this.y = b.x;
          return this;
        }

        dot(b) {
          return this.x*b.x + this.y*b.y;
        }

        length() {
          return Math.sqrt(this.x*this.x + this.y*this.y);
        }

        mul(b) {
          let c = vstack.next().load(this);

          c.x = this.x*b.x;
          c.y = this.y*b.y;

          return c;
        }

        negate() {
          let c = vstack.next().load(this);

          c[0] = -this[0];
          c[1] = -this[1];

          return c;
        }

        inegate() {
          this[0] = -this[0];
          this[1] = -this[1];

          return this;
        }

        mulScalar(b) {
          let c = vstack.next().load(this);

          c.x = this.x*b;
          c.y = this.y*b;

          return c;
        }

        div(b) {
          let c = vstack.next().load(this);

          c.x = this.x/b.x;
          c.y = this.y/b.y;

          return c;
        }

        divScalar(b) {
          let c = vstack.next().load(this);

          c.x = this.x/b;
          c.y = this.y/b;

          return c;
        }

        /* inplace operators */
        iadd(b) {
          this.x += b.x;
          this.y += b.y;
          return this;
        }

        iaddScalar(b) {
          this.x += b;
          this.y += b;
          return this;
        }

        isub(b) {

          this.x -= b.x;
          this.y -= b.y;

          return this;
        }

        isubScalar(b) {
          this.x -= b;
          this.y -= b;
          return this;
        }

        imul(b) {
          this.x *= b.x;
          this.y *= b.y;
          return this;
        }

        imulScalar(b) {
          this.x *= b;
          this.y *= b;
          return this;
        }

        idiv(b) {
          this.x /= b.x;
          this.y /= b.y;
          return this;
        }

        idivScalar(b) {
          this.x /= b;
          this.y /= b;
          return this;
        }

        add(b) {
          let c = vstack.next().load(this);

          c.x = this.x + b.x;
          c.y = this.y + b.y;

          return c;
        }

        addScalar(b) {
          let c = vstack.next().load(this);
          c.x = this.x + b;
          c.y = this.y + b;
          return c;
        }

        subScalar(b) {
          let c = vstack.next().load(this);
          c.x = this.x - b;
          c.y = this.y - b;
          return c;
        }

        sub(b) {
          let c = vstack.next().load(this);

          c.x = this.x - b.x;
          c.y = this.y - b.y;

          return c;
        }

        normalize() {
          let l = this.length();

          if (l >= 0.00000001) {
            this.imulScalar(1.0/l);
          }

          return this;
        }

        get 0() {
          return this.x;
        }

        set 0(v) {
          this.x = v;
        }

        get 1() {
          return this.y;
        }

        set 1(v) {
          this.y = v;
        }

        clone() {
          return vstack.next().load(this);
        }
      }

      class Mat2 extends Array {
        constructor(row1 = new Vec2().loadXY(1, 0), row2 = new Vec2().loadXY(0, 1)) {
          super();

          this.push(row1);
          this.push(row2);
        }

        load(m) {
          this.loadRows(m[0], m[1]);
          return this;
        }

        clone() {
          return mstack.next().load(this);
        }

        loadCols(c1, c2) {
          this[0].x = c1.x;
          this[1].x = c1.y;

          this[0].y = c2.x;
          this[1].y = c2.y;

          return this;
        }

        loadRows(r1, r2) {
          this[0].load(r1);
          this[1].load(r2);

          return this;
        }

        mul(b) {
          let c = mstack.next();

          let r1 = this[0], i1 = b[0];
          let r2 = this[1], i2 = b[1];

          let r1x = r1.x, r1y = r1.y;
          let r2x = r2.x, r2y = r2.y;
          let i1x = i1.x, i1y = i1.y;
          let i2x = i2.x, i2y = i2.y;

          c[0].x = i1x*r1x + i2x*r1y;
          c[0].y = i1y*r1x + i2y*r1y;

          c[1].x = i1x*r2x + i2x*r2y;
          c[1].y = i1y*r2x + i2y*r2y;

          return c;
        }

        itranspose() {
          let t = this[0].y;
          this[0].y = this[1].x;
          this[1].x = t;

          return this;
        }

        mulVec(b) {
          let c = vstack.next();

          c.x = this[0].x*b.x + this[0].y*b.y;
          c.y = this[1].x*b.x + this[1].y*b.y;

          return c;
        }

        det() {
          return this[0].x*this[1].y - this[0].y*this[1].x;
        }

        inverse() {
          let r1 = this[0];
          let r2 = this[1];

          let r1x = r1.x, r1y = r1.y;
          let r2x = r2.x, r2y = r2.y;

          let ret = mstack.next();

          let invDet = 1.0/(r1x*r2y - r1y*r2x);

          ret[0].x = r2y*invDet;
          ret[0].y = -r1y*invDet;
          ret[1].x = -r2x*invDet;
          ret[1].y = r1x*invDet;

          return ret;

          /*
          on factor;
          off period;

          im := mat((i1x, i1y), (i2x, i2y));
          m  := mat((r1x, r1y), (r2x, r2y));
          m2 := m*im;

          f1 := m2(1, 1) - 1;
          f2 := m2(2, 2) - 1;
          f3 := m2(1, 2);
          f4 := m2(2, 1);

          ff := solve({f1, f2, f3, f4}, {i1x, i1y, i2x, i2y});

          */
        }

        print() {
          console.log(this.toString());
        }

        toString(d = 4) {
          return `
${this[0].x.toFixed(d)}, ${this[0].y.toFixed(d)}
${this[1].x.toFixed(d)}, ${this[1].y.toFixed(d)}
`.trim();
        }
      }

      window.Mat2 = Mat2;
      window.Vec2 = Vec2;

      function vec2(x, y) {
        return vstack.next().loadXY(x, y);
      }

      function mat2(r1, r2) {
        //return mstack.next().loadCols(r1, r2);
        return mstack.next().loadRows(r1, r2);
      }

      function normalize(v) {
        return vstack.next().load(v).normalize();
      }

      function length(v) {
        return v.length();
      }

      function inverse(m) {
        return m.inverse().itranspose();
      }

      vstack = new TempStack(Vec2, 8000);
      mstack = new TempStack(Mat2, 512);

      let ShaderDef = {
        Final: {
    vertex: `
      #version 300 es
      precision highp float;
      in vec2 co;
      out vec2 vCo;
      
      void main() {
        gl_Position = vec4((co-0.5)*2.0, 0.0, 1.0);
        vCo = co;
      }`.trim(),

    fragment  : `
        #version 300 es
        precision highp float;
        
        uniform sampler2D rgba;
        uniform vec2 iRes;
        uniform float sharpness;
        uniform float SLIDERS[11];
        uniform float T;
        
        in vec2 vCo;
        out vec4 fragColor;

        #ifndef OLD_GRADIENT
        uniform float rgrad[GRAD_STEPS];
        uniform float ggrad[GRAD_STEPS];
        uniform float bgrad[GRAD_STEPS];
        uniform float agrad[GRAD_STEPS];
        #endif
        
      vec3 rgb_to_hsv(float r, float g, float b) {
        float computedH = 0.0;
        float computedS = 0.0;
        float computedV = 0.0;

        float minRGB = min(r, min(g, b));
        float maxRGB = max(r, max(g, b));

        // Black-gray-white
        if (minRGB == maxRGB) {
          return vec3(0, 0, minRGB); 
        }

        // Colors other than black-gray-white:
        float d = (r == minRGB) ? g - b : ((b == minRGB) ? r - g : b - r);
        float h = (r == minRGB) ? 3.0 : ((b == minRGB) ? 1.0 : 5.0);

        computedH = (60.0*(h - d/(maxRGB - minRGB)))/360.0;
        computedS = (maxRGB - minRGB)/maxRGB;
        computedV = maxRGB;

        return vec3(computedH, computedS, computedV);
      }
      
      vec3 hsv_to_rgb(float h, float s, float v) {
        float c = 0.0, m = 0.0, x = 0.0;

        h *= 360.0;

        c = v*s;
        x = c*(1.0 - abs(mod((h/60.0), 2.0) - 1.0));
        m = v - c;

        if (h >= 0.0 && h < 60.0) {
          return vec3(c + m, x + m, m);
        } else if (h >= 60.0 && h < 120.0) {
          return vec3(x + m, c + m, m);
        } else if (h >= 120.0 && h < 180.0) {
          return vec3(m, c + m, x + m);
        } else if (h >= 180.0 && h < 240.0) {
          return vec3(m, x + m, c + m);
        } else if (h >= 240.0 && h < 300.0) {
          return vec3(x + m, m, c + m);
        } else if (h >= 300.0 && h < 360.0) {
          return vec3(c + m, m, x + m);
        } else {
          return vec3(m, m, m);
        }

        return vec3(0.0, 0.0, 0.0);
      }
      
      float tent(float f) {
        return 1.0 - abs(fract(f)-0.5)*2.0;
      }
      
      vec2 tent(vec2 p) {
        return vec2(tent(p.x), tent(p.y));
      }

      float hash(float seed) {
          float f = fract(sin(seed*13.0) + seed*8.9);
          //float f = fract(seed);
          return fract(1.0 / (f*0.0001 + 0.0000001));
      }

      float hash2(vec2 p) {
          p *= 1.0;
          float a = 0.445325234;// + 0.01*fract(T*0.1);
          
          p += tent(p*4.1234)*2.0 - 1.0;
          
          float f = p[0]*a + p[1]/a;
          
          f += T*100.0;
          
          return hash(f);
          return fract(f);
      }
      
#ifndef NO_GRADIENT
#ifndef OLD_GRADIENT
        float evalgrad(float t, float grad[GRAD_STEPS]) {
          float t1 = floor(t*float(GRAD_STEPS));
          float t2 = ceil(t*float(GRAD_STEPS));
          float s = fract(t*float(GRAD_STEPS));

          int i1 = int(t1);
          int i2 = int(t2);

          i2 = max(0, min(i2, GRAD_STEPS-1));

          return mix(grad[i1], grad[i2], s);
        }
#endif

        vec4 fsample(vec2 uv) {
          vec4 color = texture(rgba, uv).rgba;
          
          color.rgb /= color.a;

#ifndef OLD_GRADIENT
          float f = color.r;

          color.r = evalgrad(f, rgrad);
          color.g = evalgrad(f, ggrad);
          color.b = evalgrad(f, bgrad);
          color.a = 1.0;
#else
          float f = color.r;
          
          f = mix(f*1.5, pow(f, 1.0 / SLIDERS[2]), 0.5);
          f = tent(f*SLIDERS[7]+0.5);
          
          float off = SLIDERS[3];
          float f2 = f*pow(off*0.05, 0.25) + off + 0.45;
          
          color.r = tent(f2);
          color.g = tent(f2*2.0+0.234);
          color.b = tent(f2*3.0+0.7324);
          color.a = 1.0;
          
          color.rgb = normalize(color.rgb);
          //color.b *= 0.1;
          color.rgb *= f*1.5*SLIDERS[8];
          //color.rgb = vec3(f, f, f)*SLIDERS[8]*1.5;
         
#endif

          color.rgb += (vec3(hash2(uv), hash2(uv+0.23423), hash2(uv+0.432))-0.5) / 255.0;
          return color;
        }
#else
        vec4 fsample(vec2 uv) {
          vec4 color = texture(rgba, uv).rgba;
          float f = color.r / color.a;
          f *= 3.0;
          f += (hash2(uv)-0.5)/255.0;
          
          return vec4(f, f, f, 1.0);
        }
#endif        
        void main() {          
          float du = 1.0 / iRes.x;
          float dv = 1.0 / iRes.y;
          
          float w1 = 2.0, w2, w3, w4, w5;
          
          w2 = w3 = w4 = w5 = -sharpness*0.5;
          
          fragColor = fsample(vCo)*w1
                    + fsample(vCo + vec2(-du, -dv))*w2
                    + fsample(vCo + vec2(-du, dv))*w3
                    + fsample(vCo + vec2(du, dv))*w3
                    + fsample(vCo + vec2(du, -dv))*w5;
                    
          fragColor /= w1+w2+w3+w4+w5;
          
  #ifdef PRINT_TEST
          vec3 hsv = rgb_to_hsv(fragColor.r, fragColor.g, fragColor.b);
          
          float cutoff = hsv[1]*0.5 + 0.5;
          cutoff = pow(cutoff, 0.5);
          
          
          float value = min(hsv[2], cutoff);
          float delta = abs(value - hsv[2]);
          
          hsv[2] = value;
          hsv[1] = max(hsv[1] - delta*0.5, 0.0);
          
          fragColor.rgb = hsv_to_rgb(hsv.r, hsv.g, hsv.b);
          
          //float f = abs(1.5-hsv[1]);
          //fragColor.rgb = vec3(f, f, f);
  #endif
        }`.trim(),
          attributes: ["co"]
        }
      };

      let Shaders = window._Shaders = {};

      function loadShaders(gl) {
        for (let k in ShaderDef) {
          let def = ShaderDef[k];
          Shaders[k] = new webgl.ShaderProgram(gl, def.vertex, def.fragment, def.attributes);
        }
      }

      var Render = util.Class([
        function constructor(fbos) {
          this.buffer = new webgl.RenderBuffer();
          this.regen = 1;
          this.fbos = fbos;

          this._last_update_key = '';

          this.drawGen = 0;
          this.sample = 0;
          this.lastDrawGen = 0;
        },

        function regen_buffers(gl) {
          this.regen = 0;
          var mesh = [
            0, 0, 0, 1, 1, 1,
            0, 0, 1, 1, 1, 0
          ];

          var vbuf = this.vbuf = this.buffer.get(gl, "vertex")

          gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh), gl.STATIC_DRAW);
        },

        function draw(gl) {
          if (this.regen) {
            this.regen_buffers(gl);
            this.compile_shader(gl);
          }

          for (let fbo of this.fbos) {
            fbo.update(gl, canvas.width, canvas.height);
          }

          let defines = {};

          defines.STEPS = ~~SLIDERS[0];

          if (config.SIMPLE_MODE) {
            defines.SIMPLE_MODE = null;
          }
          
          if (config.NO_GRADIENT) {
            defines.NO_GRADIENT = true;
          }

          if (config.OLD_GRADIENT) {
            defines.OLD_GRADIENT = null;
          } else {
            defines.GRAD_STEPS = config.GRADIENT.tableSteps;
          }

          if (config.USE_MONTY_SHARPNESS) {
            defines.USE_SHARPNESS = null;
          }

          if (config.PRINT_TEST) {
            defines.PRINT_TEST = null;
          }
          
          if (config.PER_PIXEL_RANDOM) {
            defines.PER_PIXEL_RANDOM = null;
          }

          let updatekey = JSON.stringify(defines) + ":" + config.FILTER_WIDTH;

          if (updatekey !== this._last_update_key) {
            this.drawGen++;
          }

          this._last_update_key = updatekey;

          let enableAccum = 1.0;

          if (this.drawGen !== this.lastDrawGen) {
            enableAccum = 0.0;
            window.T = 0.0;
            this.sample = 0;
          }
          this.lastDrawGen = this.drawGen;

          let skip = this.sample > config.MAX_SAMPLES;
          this.sample++;

          var vbuf = this.vbuf;
          var shader = this.shader;

          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

          gl.disable(gl.DEPTH_TEST);
          gl.disable(gl.DITHER);

          gl.viewport(0, 0, canvas.width, canvas.height);

          _appstate.glSize[0] = canvas.width;
          _appstate.glSize[1] = canvas.height;

          let uniforms = {
            iRes       : [canvas.width, canvas.height],
            aspect     : canvas.width/canvas.height,
            rgba       : this.fbos[1].texColor,
            enableAccum,
            T          : window.T,
            filterWidth: config.FILTER_WIDTH,
            sharpness  : config.SHARPNESS
          };

          //SLIDERS2[0] = cfract(SLIDERS2[0], Math.max(Math.ceil(SLIDERS2[1]*10.0), 1));
          let slider_uniforms = {};

          for (let i = 0; i < SLIDERS.length; i++) {
            slider_uniforms["SLIDERS[" + i + "]"] = i === 4 ? 1.0/SLIDERS[i] : SLIDERS[i];
          }

          Object.assign(uniforms, slider_uniforms);

          if (!skip) {
            shader.bind(gl, uniforms, defines);

            this.fbos[0].bind(gl);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            this.fbos[0].unbind(gl);
          }

          gl.bindFramebuffer(gl.FRAMEBUFFER, null);

          let final_uniforms = {
            iRes     : [canvas.width, canvas.height],
            aspect   : canvas.width/canvas.height,
            rgba     : this.fbos[0].texColor,
            sharpness: config.USE_SHARPNESS ? config.SHARPNESS*0.99 : 0.0,
            enableAccum,
            T        : window.T
          };

          Object.assign(final_uniforms, slider_uniforms);

          if (!config.OLD_GRADIENT) {
            let tables = config.GRADIENT.getTables();
            let steps = config.GRADIENT.tableSteps;

            for (let i = 0; i < steps; i++) {
              final_uniforms[`rgrad[${i}]`] = tables[0][i];
              final_uniforms[`ggrad[${i}]`] = tables[1][i];
              final_uniforms[`bgrad[${i}]`] = tables[2][i];
              //final_uniforms[`agrad[${i}]`] = tables[3][i];
            }
          }

          shader = Shaders.Final;
          shader.bind(gl, final_uniforms, defines);
          gl.drawArrays(gl.TRIANGLES, 0, 6);

          if (!skip) {
            let t = this.fbos[0];
            this.fbos[0] = this.fbos[1];
            this.fbos[1] = t;
          }
        },

        function compile_shader(gl) {
          var code = document.getElementById("fragment").text;

          let vshader = `
      #version 300 es
      precision highp float;
      in vec2 co;
      out vec2 vCo;
      
      void main() {
        gl_Position = vec4((co-0.5)*2.0, 0.0, 1.0);
        vCo = co;
      }`.trim();

          let fshader = `
        #version 300 es
        precision highp float;
        ${code}
        
        in vec2 vCo;
        out vec4 fragColor;
        
        void main() {
          vec2 p = vCo * iRes.xy;
          fragColor = shader(p[0], p[1]);
        }
      `.trim();

          var shader = new webgl.ShaderProgram(gl, vshader, fshader, ["co"]);
          shader.defines = {STEPS: ~~SLIDERS[0]};
          shader.init(gl);
          this.shader = shader;
        }
      ]);

      class AnimJob {
        constructor(cb, id, steps) {
          this.cb = cb;
          this.id = id;
          this.steps = steps;
          this.timerid = undefined;
          this.promise = undefined;
        }

        finish() {
          if (this.timerid === undefined) {
            console.log("not running");
            return;
          }

          this.cb(1.0);
          this._accept();

          this.stop();
        }

        stop() {
          if (this.timerid === undefined) {
            console.log("not running");
            return;
          }

          window.clearInterval(this.timerid);
          this.timerid = undefined;
          this.promise = undefined;
          this._accept = undefined;
        }

        start(cb, steps) {
          let i = 0;

          this.cb = cb;
          this.steps = steps;

          this.timerid = window.setInterval(() => {
            if (this.steps > 0 && i >= this.steps) {
              window.clearInterval(this.timerid);
              this.timerid = undefined;
              this._accept();
            }

            let t = i/(this.steps - 1);
            this.cb(t);

            i++;
          }, 5);

          this.promise = new Promise((accept, reject) => {
            this._accept = accept;
          });

          return this.promise;
        }
      }

      class Animator {
        constructor() {
          this.tasks = [];
          this.task_idmap = new Map();
        }

        run(id, cb, steps = 16, finishExisting = true) {
          let anim = this.task_idmap.get(id);

          if (!anim) {
            anim = new AnimJob(cb, id, steps);

            this.task_idmap.set(id, anim);
            this.tasks.push(anim);
          } else {
            if (finishExisting) {
              anim.finish();
            } else {
              anim.stop();
            }
          }

          return anim.start(cb, steps);
        }

        finish(id) {
          if (this.task_idmap.has(id)) {
            this.task_idmap.get(id).finish();
          }
        }

        stop(id) {
          if (this.task_idmap.has(id)) {
            this.task_idmap.get(id).stop();
          }
        }

        stopAll() {
          for (let task of this.tasks) {
            task.stop();
          }
        }

        finishAll() {
          for (let task of this.tasks) {
            task.finish();
          }
        }
      }

      const pow = Math.pow, sqrt = Math.sqrt, floor = Math.floor;
      const fract = Math.fract, tent = Math.tent;

      function cmul(a, b) {
        return vec2(
          a.x*b.x - a.y*b.y,
          a.x*b.y + b.x*a.y
        );
      }

      function fsample(z, p) {
        const d = 1.0;

        //(z-1)(z+1)(z-p)
        let a = z.sub(vec2(d, 0.0));
        let b = z.add(vec2(d, 0.0));
        let c = z.sub(p);

        return cmul(cmul(a, b), c);
      }

      class PathPoint {
        constructor(startx, starty) {
          this.co = new Vec2();
          this.t = 0;
          this.w = 0;
        }
      }

      class Path extends Array {
        constructor(startx, starty) {
          super();

          this.co = new Vec2().loadXY(startx, starty);
          this.tmp = [0, 0];
        }

        pathRun(uv, iRes) {
          let seed, dr, di, f = 0.0, dist = 0.0, z;

          let startuv = uv.clone();

          let tm = 0.0;
          let tm2 = 0.0;

          seed = uv.clone();
          //seed = vec2(0.2, 0.4132432);

          //return tent(uv.y*1.23423);

          tm = SLIDERS[1];
          tm = pow(tm, 1.0/1.0);
          let toff = pow(tm, 0.25);

          mstack.push();
          vstack.push();

          //for (let i=0; i<steps; i++) {
          z = cmul(uv, vec2(0.333333 + tm*0.5, 0.0 + tm)); //0.85*toff));

          let a = fsample(z, seed);

          //anayltical derivatives
          let p = seed;

          let zx = z.x, zy = z.y;
          let px = p.x, py = p.y;

          dr = vec2(0, 0);
          di = vec2(0, 0);

          dr.x = -(2.0*((px - zx)*zx - (py - zy)*zy) + zy*zy + 1.0 - zx*zx);
          dr.y = -2.0*((py - zy - zy)*zx + (px - zx)*zy);

          di.x = 2.0*((py - zy - zy)*zx + (px - zx)*zy);
          di.y = -(2.0*((px - zx)*zx - (py - zy)*zy) + zy*zy + 1.0 - zx*zx);

          //heissan matrices
          let rxm = mat2(vec2(4.0*(px - 3.0*zx)*(px - 3.0*zx), -4.0*(px - 3.0*zx)*(py - 3.0*zy)),
            vec2(-4.0*(px - 3.0*zx)*(py - 3.0*zy), 4.0*(py - 3.0*zy)*(py - 3.0*zy)));

          let rym = mat2(vec2(4.0*(py - 3.0*zy)*(py - 3.0*zy), 4.0*(px - 3.0*zx)*(py - 3.0*zy)),
            vec2(4.0*(px - 3.0*zx)*(py - 3.0*zy), 4.0*(px - 3.0*zx)*(px - 3.0*zx)));

          let ixm = mat2(vec2(4.0*(py - 3.0*zy)*(py - 3.0*zy), 4.0*(px - 3.0*zx)*(py - 3.0*zy)),
            vec2(4.0*(px - 3.0*zx)*(py - 3.0*zy), 4.0*(px - 3.0*zx)*(px - 3.0*zx)));

          let iym = mat2(vec2(4.0*(px - 3.0*zx)*(px - 3.0*zx), -4.0*(px - 3.0*zx)*(py - 3.0*zy)),
            vec2(-4.0*(px - 3.0*zx)*(py - 3.0*zy), 4.0*(py - 3.0*zy)*(py - 3.0*zy)));

          let m = inverse(mat2(dr, di));

          let off = m.mulVec(a).negate();
          //off.xy += vec2(-off.y, off.x)*0.35;
          off.iadd(vec2(-off.y, off.x).imulScalar(SLIDERS[10]));

          dist += 2.0*length(off)/(0.2 + length(iym.mul(rxm).mulVec(off)));

          //dist += 0.12 / (0.1 + length(rym*off));

          //dist += (determinant(rxm) + determinant(rym) + determinant(ixm) + determinant(iym))*1000.0;
          //dist += determinant(rxm*rym*ixm*iym)*100000.0;
          //dist += (abs(off[0]) + abs(off[1]))*0.5;
          //dist += max(abs(off[0]), abs(off[1]));

          off.imulScalar(0.5);
          uv.iadd(off);
          //}

          mstack.pop();
          vstack.pop();

          let d1 = length(uv.sub(vec2(-1.0, 0.0)));
          let d2 = length(uv.sub(vec2(1.0, 0.0)));
          let d3 = length(uv.sub(seed));

          //find closest root shade
          f = d1 < d2 ? 1.0 : 0.75;
          f = d3 < d2 && d3 < d1 ? 0.5 : f;

          let tfac = pow(1.0 - toff, 0.25);
          let dfract;
          dfract = tent(dist*0.004);
          f = sqrt(dfract)*0.5;

          return f;
        }

        step(state) {
          let p = new PathPoint();
          p.co.x = this.co.x;
          p.co.y = this.co.y;

          this.push(p);

          this.pathRun(this.co, vec2(state.glSize[0], state.glSize[1]));
        }

        draw(state, g) {
          g.strokeStyle = "rgba(255, 150, 5, 0.025)";
          let r = 1.25;

          let tmp = this.tmp;
          let first = true;

          g.beginPath();

          for (let p of this) {
            tmp[0] = p.co.x;
            tmp[1] = p.co.y;
            state.untransform(tmp);

            if (first) {
              g.moveTo(tmp[0], tmp[1]);
              first = false;
            } else {
              g.lineTo(tmp[0], tmp[1]);
            }
          }

          g.stroke();

          g.strokeStyle = "rgba(25, 255, 105, 0.25)";
          tmp[0] = this.co.x;
          tmp[1] = this.co.y;

          state.untransform(this.tmp);
          let x = this.tmp[0], y = this.tmp[1];

          g.beginPath();
          g.arc(x, y, r, -Math.PI, Math.PI);
          g.stroke();
          //g.fill();
        }
      }

      let animManager = new Animator();

      function calcViewKey(sliders = SLIDERS) {
        return "" + sliders[4].toFixed(4) + ":" + sliders[5].toFixed(4) + ":" + sliders[6].toFixed(4);
      }

      var config = window.config = {
        DPI                : 1.0,
        SLIDERS            : window.SLIDERS,
        PRESET             : null,
        NO_GRADIENT        : false,
        GRADIENT           : new ui.Gradient(),
        SHOW_SLIDERS       : true,
        SHARPNESS          : 0.5,
        USE_SHARPNESS      : true,
        USE_MONTY_SHARPNESS: false,
        FILTER_WIDTH       : 1.5,
        PER_PIXEL_RANDOM   : true,
        MAX_SAMPLES        : 100,
        OLD_GRADIENT       : false,
        VERSION            : 0.1,
        LOCK_OFFSETS       : false,
        SIMPLE_MODE        : false,
        PRINT_TEST         : false,
      };

      let NonPresetKeys = new Set([
        "DPI", "gui", "MAX_SAMPLES", "SHOW_SLIDERS",
        "PRESET", "COLOR", "VERSION"
      ]);

      class Preset {
        constructor(name) {
          this.name = name;
          this.config = undefined;
          this.builtin = false;

          this.sorti = 0;
          this.update(true);
        }

        copy() {
          return new Preset().loadJSON(JSON.parse(JSON.stringify(this)));
        }

        update(noReport = false) {
          if (!noReport) {
            console.warn("Updating preset " + this.name);
          }

          let config2 = Object.assign({}, config, {SLIDERS: window.SLIDERS});

          for (let key of NonPresetKeys) {
            if (key in config2) {
              delete config2[key];
            }
          }

          //if (!this.config && (config2.OLD_GRADIENT || config2.NO_GRADIENT)) {
          //delete config2.GRADIENT;
          //}

          //copy
          this.config = JSON.parse(JSON.stringify(config2));
        }

        toJSON() {
          let {config, name, builtin} = this;

          return {config, name, builtin};
        }

        loadJSON(json) {
          this.config = json.config;
          this.name = json.name;
          this.builtin = !!json.builtin;

          for (let k of NonPresetKeys) {
            if (k in this.config) {
              delete this.config[k];
            }
          }

          return this;
        }

        static localStorageKey() {
          return LOCAL_STORAGE_KEY + "_presets";
        }
      }

      //config.GRADIENT = {"stops":[{"color":[1,1,1,1],"t":-0.03401360544217687,"flag":0,"type":2,"id":1},{"color":[0.023529411764705882,0.2124567474048444,0.3803921568627451,1],"t":0.07908158075241817,"flag":0,"type":2,"id":3},{"color":[0,0.025374855824682917,0.21568627450980393,1],"t":0.14285709095649976,"flag":0,"type":2,"id":3},{"color":[1,0.3529411764705883,0,1],"t":0.3767006283714658,"flag":0,"type":2,"id":7},{"color":[1,1,1,1],"t":0.6955781793918738,"flag":0,"type":2,"id":5},{"color":[1,0.588235294117647,0,1],"t":0.7083332814326901,"flag":0,"type":2,"id":3},{"color":[0,0.5098039215686274,0.42352941176470593,1],"t":1.005952329051738,"flag":0,"type":2,"id":6}],"brightness":-0.03460148015718023,"contrast":6.650181530849846,"active":1,"highlight":7,"version":0.1};

      //config.GRADIENT = {"stops":[{"color":[0.6799913742377214,0.9078430474973193,0.8752928084602339,1],"t":0,"flag":0,"type":2,"id":1},{"color":[0.6627448586856617,1,0.9923351104246743,1.134127878884028],"t":0.1445576155266794,"flag":0,"type":2,"id":4},{"color":[0.6641316152164686,0.939215716193704,0,1.134127878884028],"t":0.2091842962771046,"flag":0,"type":2,"id":3},{"color":[0.6764705882352942,0,0,1],"t":0.27891099371877653,"flag":0,"type":2,"id":5},{"color":[0.12941176470588237,0,0.12941176470588237,1.7189662245208588],"t":0.3520402973200998,"flag":0,"type":2,"id":4},{"color":[0.1470588235294118,0,0,1.7189662245208588],"t":0.43027169363839307,"flag":0,"type":2,"id":3},{"color":[0.11169984350190419,0.021291727185648927,0.1392153571633732,1.3163097667251147],"t":0.4744894845145089,"flag":0,"type":2,"id":5},{"color":[0,0,0,1],"t":0.8605445290909332,"flag":0,"type":2,"id":6},{"color":[0.9078430474973193,0.9078430474973193,0.9078430474973193,1.6234856701158382],"t":1,"flag":0,"type":2,"id":3}],"brightness":0.060243144399212634,"contrast":4.466571313696291,"postBrightness":0.007306296684025826,"postContrast":2.3755393077499503,"active":-1,"highlight":-1,"version":0.1};

      //config.GRADIENT = {"stops":[{"color":[0.6799913742377214,0.9078430474973193,0.8752928084602339,1],"t":0,"flag":0,"type":2,"id":1},{"color":[0.6627448586856617,1,0.9923351104246743,1.134127878884028],"t":0.03911523105335882,"flag":0,"type":2,"id":4},{"color":[0.6641316152164686,0.939215716193704,0,1.134127878884028],"t":0.0867351090826956,"flag":0,"type":2,"id":3},{"color":[0.6764705882352942,0,0,1],"t":0.17687017739224592,"flag":0,"type":2,"id":5},{"color":[0.12941176470588237,0,0.12941176470588237,1.7189662245208588],"t":0.39625808819621583,"flag":0,"type":2,"id":4},{"color":[0.1470588235294118,0,0,1.7189662245208588],"t":0.47789079315808375,"flag":0,"type":2,"id":3},{"color":[0.3647058823529412,0.4477511818433717,0.9529411764705882,1.3163097667251147],"t":0.6139454744300062,"flag":0,"type":2,"id":5},{"color":[0,0,0,1],"t":0.8877555172459608,"flag":0,"type":2,"id":6},{"color":[0.9078430474973193,0.9078430474973193,0.9078430474973193,1.6234856701158382],"t":1,"flag":0,"type":2,"id":3}],"brightness":-0.36324759860240097,"contrast":4.4996583057368165,"postBrightness":-0.010338870474382977,"postContrast":1.627837652632059,"active":-1,"highlight":-1,"version":0.1}
      //SLIDERS = [188.34821428571422, 0.6982142857142852, 0.18750000000000028, 1.7085714612688336, 16.19987478917088, 6.747283968091449, 6.759060231398961, 9.836785643441342, 0.9617142312186068, 1.539385714285714, 0.2742857251848492]

      //config.GRADIENT = {"stops":[{"color":[0.6799913742377214,0.9078430474973193,0.8752928084602339,1],"t":0,"flag":0,"type":2,"id":1},{"color":[0.6627448586856617,1,0.9923351104246743,1.134127878884028],"t":0.03911523105335882,"flag":0,"type":2,"id":4},{"color":[0.8734639352702891,0.4823524624693627,1,1.134127878884028],"t":0.08333380043912099,"flag":0,"type":2,"id":3},{"color":[0.6764705882352942,0,0,1],"t":0.29251648779629036,"flag":0,"type":2,"id":5},{"color":[0.12941176470588237,0,0.12941176470588237,1.7189662245208588],"t":0.39625808819621583,"flag":0,"type":2,"id":4},{"color":[0.1470588235294118,0,0,1.7189662245208588],"t":0.505101521809896,"flag":0,"type":2,"id":3},{"color":[0.3647058823529412,0.4477511818433717,0.9529411764705882,1.3163097667251147],"t":0.756802513485863,"flag":0,"type":2,"id":5},{"color":[0,0,0,1],"t":0.8877555172459608,"flag":0,"type":2,"id":6},{"color":[0.9078430474973193,0.9078430474973193,0.9078430474973193,1.6234856701158382],"t":1,"flag":0,"type":2,"id":3}],"brightness":0.007306296684025826,"contrast":3.3416842614451854,"postBrightness":0.07788831155762155,"postContrast":1.9255944664320952,"active":3,"highlight":3,"version":0.1}

      //config.GRADIENT = {"stops":[{"color":[0,0,0,1],"t":0,"flag":0,"type":2,"id":8},{"color":[0.28431372549019607,0.030103772202623384,0.2679130833426107,1],"t":0.22363940388166983,"flag":0,"type":2,"id":12},{"color":[1,0,0,1],"t":0.42602040816326525,"flag":0,"type":2,"id":9},{"color":[1,0.6516555482978063,0.6516555482978063,1],"t":0.6360543698680644,"flag":0,"type":2,"id":11},{"color":[1,1,1,1],"t":1,"flag":0,"type":2,"id":10}],"brightness":1.0263305184016698,"contrast":8.304430165552176,"postBrightness":-0.05445246149038524,"postContrast":1.7270899238987378,"active":9,"highlight":9,"version":0.1,"idgen":13,"satOffset":1,"hueOffset":0}

      class AppState {
        constructor(gl, canvas, g, canvas2d) {
          this.gl = gl; //3d api
          this.g = g;   //2d api
          this.mdown = false;

          this.presets = [];
          this.presetNames = [];

          this.image = undefined;

          this.newUndoStack = new undostack.UndoStack();

          this.newUndoStack.onpush = () => {
            animManager.finish("zoom");
          }

          this.newUndoStack.onundo = this.newUndoStack.onredo = () => {
            animManager.stop("zoom");
            this.render.drawGen++;
            this.save();
          }

          this.gui = new ui.UI(config, undefined, this.newUndoStack);
          this.makeGui();
          this.gui.listen();

          this.undoStack = [];
          this.undoCur = 0;

          this.paths = [];
          this._last_view_key = calcViewKey();
          this._last_size_key = '';

          this.fbos = new Array(2);
          for (let i = 0; i < this.fbos.length; i++) {
            this.fbos[i] = new webgl.FBO(gl, canvas.width, canvas.height);
            this.fbos[i].create(gl);
          }

          this.sliderUndoGen = 0;

          this.glSize = [512, 512];

          this.drawrect = undefined;

          this.canvas2d = canvas2d;
          this.canvas = canvas;
          this.render = new Render(this.fbos);

          this.mpos = [0, 0];

          this.sliders = new sliders.SliderManager(50, 50, 25,
            window.innerHeight - 150, SLIDERS, SLIDER_NAMES);
          this.sliders.correctForDPI = true;

          let pass_sliders = new Set();
          for (let p of ["gain", "color", "colorscale", "brightness"]) {
            for (let i = 0; i < SLIDER_NAMES.length; i++) {
              let name = SLIDER_NAMES[i];

              if (typeof name === "object") {
                name = name.name;
              }

              if (name === p) {
                pass_sliders.add(i);
              }
            }
          }

          let last = SLIDERS.concat([]);
          
          this.sliders.onchange = (acti) => {
            if (config.LOCK_OFFSETS && (acti == 10 || acti == 1)) {
              let dv = SLIDERS[acti] - last[acti];
              
              if (acti == 10) {
                SLIDERS[1] += -dv;
              } else {
                SLIDERS[10] += -dv;
              }
            }
            
            last[acti] = SLIDERS[acti];
            
            console.log("SLIDER CHANGE", acti);

            if (pass_sliders.has(acti)) {
              return;
            }

            this.render.drawGen++;
          }

          let oldpix;
          this.sliders.onchange_start = () => {
            this.undoPush(this.sliderUndoGen, true);

            console.warn("onchange_start!");
            
            if (oldpix === undefined) {
              oldpix = config.DPI;
              config.DPI = Math.min(config.DPI, 0.4);
            }
          }

          this.sliders.onchange_end = () => {
            console.warn("onchange_end!");
            
            if (oldpix !== undefined) {
              config.DPI = oldpix;
            }
            
            oldpix = undefined;
            this.sliderUndoGen++;
          }

          this.sliders.pad = 6;
          //this.sliders.localStorageKey = LOCAL_STORAGE_KEY + "_params";

          window.addEventListener("keydown", (e) => this.on_keydown(e));

          let dotouch = (e) => {
            let x = e.touches.length > 0 ? e.touches[0].pageX : this.mpos[0];
            let y = e.touches.length > 0 ? e.touches[0].pageY : this.mpos[1];

            return Object.assign({x, y, button: 0}, e);
          }

          let dom = this.canvas2d;

          dom.addEventListener("mousedown", (e) => {
            return this.on_mousedown(e);
          });
          dom.addEventListener("mousemove", (e) => {
            return this.on_mousemove(e);
          });
          dom.addEventListener("mouseup", (e) => {
            return this.on_mouseup(e);
          });

          dom.addEventListener("touchstart", (e) => {
            e.preventDefault();
            return this.on_mousedown(dotouch(e));
          });
          dom.addEventListener("touchend", (e) => {
            e.preventDefault();
            return this.on_mouseup(dotouch(e));
          });
          dom.addEventListener("touchmove", (e) => {
            e.preventDefault();
            return this.on_mousemove(dotouch(e));
          });

          this.sliders.bind_events(dom);

          this.undoPush();
        }

        updatePresetNames() {
          this.presetNames.length = 0;

          for (let p of this.presets) {
            this.presetNames.push(p.name);
          }
        }

        makeGui() {
          let gui = this.gui;

          gui.gradient("GRADIENT", "Gradient");

          let panel = gui.panel("Presets");

          panel.listenum("PRESET", this.presetNames, "", "", (preset) => {
            console.warn("preset!", preset);
            let p = this.getPreset(preset);

            if (p) {
              this.loadJSON(p.config);
              config.PRESET = preset;

              this.save(false);

              if (this.gui) {
                this.gui.load();
              }

              //update here, to more accurately detect changes later
              p.update();
            } else {
              console.error("failed to load preset", preset);
            }
          });

          panel.button("Add", () => {
            let preset = new Preset();
            let name = config.PRESET || "Preset";
            let newname = name;
            let i = 2;
            let ok = false;

            while (!ok) {
              ok = true;

              for (let preset2 of this.presets) {
                if (preset2.name == newname) {
                  newname = name + " " + i;
                  i++;
                  ok = false;
                }
              }
            }

            preset.name = newname;
            this.presets.push(preset);
            this.updatePresetNames();

            config.PRESET = preset.name;
          });

          //panel.button("Load", () => {            
          //});

          gui.slider("FILTER_WIDTH", "Filter", 1.5, 0.01, 5.0, 0.001);
          gui.slider("DPI", "Pixel Size", 1.0, 0.01, 1.0, 0.001);

          gui.slider("MAX_SAMPLES", "Samples", 100, 1, 1400, 1, true);

          gui.check("SHOW_SLIDERS", "Show Sliders");
          gui.check("USE_SHARPNESS", "Sharpness Filter");
          gui.slider("SHARPNESS", "Sharpness", 0.0, 0.0, 1.0, 0.001, false, false);
          gui.check("USE_MONTY_SHARPNESS", "Monty Sharpness");

          gui.check("PER_PIXEL_RANDOM", "PixelRand");
          gui.check("OLD_GRADIENT", "Old Gradient");
          gui.check("NO_GRADIENT", "B/W");
          gui.check("LOCK_OFFSETS", "Lock Offsets");
          gui.check("SIMPLE_MODE", "Simple Mode");
          gui.check("PRINT_TEST", "Print Preview");
        }

        undoPushNew(combineId, combine = false) {
          const type = "sliders";
          const stack = this.newUndoStack;
          let head;

          if (combine && (head = stack.head) && head.type == "sliders") {
            for (let i = 0; i < SLIDERS.length; i++) {
              head.data[i] = SLIDERS[i];
            }

            console.log("found undo head");
            return;
          }

          stack.pushSwapper("sliders", SLIDERS.concat([]), (data) => {
            for (let i = 0; i < data.length; i++) {
              let t = data[i];

              data[i] = SLIDERS[i];
              SLIDERS[i] = t;
            }
          });
        }

        undoPush(combineId, combine = false) {
          animManager.finish("zoom");
          this.undoPushNew();

          if (combine && this.undoCur > 0) {
            let head = this.undoStack[this.undoCur - 1];
            if (head.id === combineId) {
              for (let i = 0; i < SLIDERS.length; i++) {
                head.sliders[i] = SLIDERS[i];
              }

              console.log("found undo head");
              return;
            }
          }

          this.undoStack.length = this.undoCur;
          this.undoCur++;
          this.undoStack.push({
            sliders: SLIDERS.concat([]),
            id     : combineId
          });
        }

        undo() {
          this.newUndoStack.undo();
          return;
          console.log("undo", this.undoCur, this.undoStack);

          if (this.undoCur <= 0) {
            return;
          }

          animManager.finish("zoom");

          this.undoCur--;
          let sliders = this.undoStack[this.undoCur].sliders;

          for (let i = 0; i < sliders.length; i++) {
            let t = SLIDERS[i];
            SLIDERS[i] = sliders[i];
            sliders[i] = t;
          }

          this.render.drawGen++;
          this.save();
          this.checkPaths();
        }

        redo() {
          this.newUndoStack.redo();
          return;
          console.log("redo", this.undoCur, this.undoStack);

          if (this.undoCur >= this.undoStack.length) {
            return;
          }

          animManager.finish("zoom");

          let sliders = this.undoStack[this.undoCur].sliders;

          for (let i = 0; i < sliders.length; i++) {
            let t = SLIDERS[i];
            SLIDERS[i] = sliders[i];
            sliders[i] = t;
          }

          this.undoCur++;
          this.render.drawGen++;
          this.save();
          this.checkPaths();
        }

        on_mousedown(e) {
          let dpi = this.getDPI();

          this.mdown = e.button === 0;
          this.drawrect = [[e.x*dpi, e.y*dpi], [e.x*dpi, e.y*dpi]];
        }

        on_mousemove(e) {
          let dpi = this.getDPI();

          if (this.mdown && this.drawrect) {
            this.drawrect[1][0] = e.x*dpi;
            this.drawrect[1][1] = e.y*dpi;
          }
        }

        transform(p, sliders = SLIDERS, size = this.glSize) {
          p[0] /= size[0];
          p[1] = (size[1] - p[1])/size[1];

          p[0] = p[0]*2.0 - 1.0;
          p[1] = p[1]*2.0 - 1.0;

          p[0] *= canvas.width/canvas.height;

          p[0] += sliders[5];
          p[1] += sliders[6];

          p[0] /= SLIDERS[4];
          p[1] /= SLIDERS[4];
        }

        untransform(p, sliders = SLIDERS) {
          p[0] *= SLIDERS[4];
          p[1] *= SLIDERS[4];

          p[0] -= sliders[5];
          p[1] -= sliders[6];

          p[0] *= canvas.height/canvas.width;

          p[0] = p[0]*0.5 + 0.5;
          p[1] = p[1]*0.5 + 0.5;

          p[0] *= this.glSize[0];
          p[1] *= this.glSize[1];

          p[1] = this.glSize[1] - p[1];
          //console.log(p);
        }

        viewChanged() {

        }

        zoom() {
          let r = this.drawrect;
          let minx = Math.min(r[0][0], r[1][0]);
          let miny = Math.min(r[0][1], r[1][1]);
          let maxx = Math.max(r[0][0], r[1][0]);
          let maxy = Math.max(r[0][1], r[1][1]);
          let w = maxx - minx;
          let h = maxy - miny;

          if (w === 0 || h === 0) {
            return;
          }

          let cx = (minx + maxx)*0.5;
          let cy = (miny + maxy)*0.5;
          // fix aspect

          let size = Math.max(w, h);

          minx = cx - size*0.5;
          miny = cy - size*0.5;

          maxx = cx + size*0.5;
          maxy = cy + size*0.5;

          let min = [minx, miny];
          let max = [maxx, maxy];

          let s = this.glSize;

          this.transform(min, undefined, s);
          this.transform(max, undefined, s);

          cx = ((min[0] + max[0])*0.5);
          cy = ((min[1] + max[1])*0.5);

          let startx = SLIDERS[5]/SLIDERS[4];
          let starty = SLIDERS[6]/SLIDERS[4];

          let scale = 1.0/(max[0] - min[0]);
          let startscale = SLIDERS[4];

          console.log("SCALE", scale);
          if (isNaN(scale)) {
            return;
          }

          animManager.finish("zoom");
          this.undoPush();
          this.clearPaths();

          if (0) {
            SLIDERS[5] = cx;
            SLIDERS[6] = cy;
          } else {
            animManager.run("zoom", (t) => {
              console.log(t);
              SLIDERS[4] = startscale + (scale - startscale)*t*t*t;

              let cx2 = cx;//*SLIDERS[4];
              let cy2 = cy;//*SLIDERS[4];

              SLIDERS[5] = (startx + (cx2 - startx)*t)*SLIDERS[4];
              SLIDERS[6] = (starty + (cy2 - starty)*t)*SLIDERS[4];
              this.save();
              this.render.drawGen++;
            }).then(() => {
            });
          }

          this.save();
          this.render.drawGen++;
        }

        toJSON() {
          config.SLIDERS = window.SLIDERS;
          let gui = this.gui;

          return Object.assign({}, config, {SLIDERS:window.SLIDERS, gui});
        }

        getPreset(name = config.PRESET) {
          for (let preset of this.presets) {
            if (preset.name == name) {
              return preset;
            }
          }
        }

        save(savePresets = true) {
          config.SLIDERS = window.SLIDERS;
          localStorage[LOCAL_STORAGE_KEY] = JSON.stringify(this);
          //this.sliders.save();

          if (savePresets) {
            this.updatePreset();
            localStorage[Preset.localStorageKey()] = JSON.stringify(this.presets);
          }
        }

        updatePreset() {
          let preset = this.getPreset(config.PRESET);
          if (!preset) {
            return;
          }

          if (preset.builtin) {
            let preset3 = preset.copy();
            preset3.update();

            if (JSON.stringify(preset3) === JSON.stringify(preset)) {
              console.warn("Builting preset was not modified");
              return;
            }

            let name = preset.name + " modified";

            let preset2 = this.getPreset(name);

            if (!preset2) {
              preset2 = preset.copy();
              preset2.builtin = false;
              preset2.name = name;

              this.presets.push(preset2);
              this.updatePresetNames();
            }

            preset = preset2;
            config.PRESET = name;
          }

          preset.update();
        }

        load() {
          //this.sliders.load();
          let json = localStorage[LOCAL_STORAGE_KEY];

          if (json === undefined) {
            return;
          }

          json = JSON.parse(json);
          this.loadJSON(json);

          this.loadPresets();

          if (this.gui) {
            this.gui.load();

            if (json.gui) {
              this.gui.loadJSON(json.gui);
            }
          }
        }

        loadJSON(json) {
          for (let k in json) {
            config[k] = json[k];
          }

          if (json.SLIDERS) {
            config.SLIDERS = window.SLIDERS;
            
            for (let i = 0; i < window.SLIDERS.length; i++) {
              window.SLIDERS[i] = json.SLIDERS[i];
              if (window.SLIDERS[i] === undefined) {
                let def = SLIDER_NAMES[i];
                window.SLIDERS[i] = def.default !== undefined ? def.default : 0.0;
              }
            }
          }

          if (this.render) {
            this.render.drawGen++;
          }
        }

        loadPresets() {
          let json = localStorage[Preset.localStorageKey()];
          if (!json) {
            return;
          }

          this.presets.length = 0;

          json = JSON.parse(json);
          for (let jpreset of json) {
            let preset = new Preset().loadJSON(jpreset);
            this.presets.push(preset);

            preset.sorti = builtin_presets.length;
          }

          let i = 0;
          for (let jpreset of builtin_presets) {
            let preset = this.getPreset(jpreset.name);

            if (!preset) {
              preset = new Preset().loadJSON(jpreset);
              this.presets.push(preset);
            } else {
              preset.loadJSON(jpreset);
            }

            preset.builtin = true;
            preset.sorti = i;
            i++;
          }

          this.presets.sort((a, b) => a.sorti - b.sorti);

          this.updatePresetNames();

          //update active preset so we can
          //detect changes more accurately free
          //of serialization noise
          let preset = this.getPreset(config.PRESET);
          preset.update();
        }

        on_tick() {

        }

        on_mouseup(e) {
          this.mdown = false;

          if (this.drawrect) {
            this.zoom();
          }
          this.drawrect = undefined;
        }

        testInternalRunWasm(steps=1) {
          for (let i=0; i<SLIDERS.length; i++) {
            wasmArgs.sliders[i] = SLIDERS[i];
          }

          return this.internalRunWasm(vec2(0.2, 0.3), vec2(1.0, 1.0), steps);
        }

        internalRunWasm(uv, iRes, steps) {
          let tm = SLIDERS[1];
          let toff = pow(tm, 0.25);

          uv.idiv(iRes).imulScalar(2.0).isubScalar(1.0);
          uv.x *= iRes.x/iRes.y;

          uv.x += SLIDERS[5];
          uv.y += SLIDERS[6]; // + 0.5*SLIDERS[4];

          uv.idivScalar(SLIDERS[4]);

          wasmArgs.uv[0] = uv.x;
          wasmArgs.uv[1] = uv.y;

          let f = wasm.exports.newtonFractal(wasmArgs.uv.byteOffset, wasmArgs.sliders.byteOffset, toff, steps);

          //debugger;
          return f;
        }

        internalRunWasmSimd(out, uv1, uv2, iRes, steps=~~SLIDERS[0]) {
          let tm = SLIDERS[1];
          let toff = pow(tm, 0.25);

          uv1.idiv(iRes).imulScalar(2.0).isubScalar(1.0);
          uv1.x *= iRes.x/iRes.y;
          uv1.x += SLIDERS[5];
          uv1.y += SLIDERS[6]; // + 0.5*SLIDERS[4];
          uv1.idivScalar(SLIDERS[4]);

          uv2.idiv(iRes).imulScalar(2.0).isubScalar(1.0);
          uv2.x *= iRes.x/iRes.y;
          uv2.x += SLIDERS[5];
          uv2.y += SLIDERS[6]; // + 0.5*SLIDERS[4];
          uv2.idivScalar(SLIDERS[4]);

          wasmArgs.simd_uv[0] = uv1.x;
          wasmArgs.simd_uv[1] = uv1.y;
          wasmArgs.simd_uv[2] = uv2.x;
          wasmArgs.simd_uv[3] = uv2.y;

          wasm.exports.newtonFractalSimd(wasmArgs.simd_out.byteOffset, wasmArgs.simd_uv.byteOffset, wasmArgs.sliders.byteOffset, toff, steps);

          //debugger;
          out[0] = wasmArgs.simd_out[0];
          out[1] = wasmArgs.simd_out[1];
        }

        internalRun(uv, iRes, steps) {
          let f = this.internalRun_intern(uv, iRes, steps);
          let tot = 1.0;
          
          let dimen = Math.max(iRes.x, iRes.y) * SLIDERS[4];
          let mul = 1.0 / dimen;
          
          const filter = 5;
          let j = 0;
          
          //_jitter
          for (let i=0; i<filter; i++) {
            let r1 = _jitter[j];
            j = (j + 1) & (_jitter.length - 1);
            
            let r2 = _jitter[j];
            j = (j + 1) & (_jitter.length - 1);
            
            r1 -= 0.5;
            r2 -= 0.5;
            r1 *= mul;
            r2 *= mul;
            
            let uv2 = vec2(uv.x+r1, uv.y+r2);
            let f2 = this.internalRun_intern(uv2, iRes, steps);
            
            f += f2;
            tot += 1.0;
          }
          
          return f / tot;
        }
        
        internalRun_intern(uv, iRes, steps = ~~SLIDERS[0]) {
          if (wasm) {
            return this.internalRunWasm(uv, iRes, steps);
          }

          //uv = uv.divScalar(iRes.x).mulScalar(2.0).subScalar(1.0);
          uv.idiv(iRes).imulScalar(2.0).isubScalar(1.0);
          uv.x *= iRes.x/iRes.y;

          uv.x += SLIDERS[5];
          uv.y += SLIDERS[6]; // + 0.5*SLIDERS[4];

          uv.idivScalar(SLIDERS[4]);

          let seed, dr, di, f = 0.0, dist = 0.0, z;

          let startuv = uv.clone();

          let tm = 0.0;
          let tm2 = 0.0;

          seed = uv.clone();
          //seed = vec2(0.2, 0.4132432);

          //return tent(uv.y*1.23423);

          tm = SLIDERS[1];
          tm = pow(tm, 1.0/1.0);
          let toff = pow(tm, 0.25);

          mstack.push();
          vstack.push();

          for (let i = 0; i < steps; i++) {
            let z = cmul(uv, vec2(0.333333 + tm*0.5, 0.0 + tm)); //0.85*toff));

            let a = fsample(z, seed);

            //anayltical derivatives
            let p = seed;

            let zx = z.x, zy = z.y;
            let px = p.x, py = p.y;

            dr = vec2(0, 0);
            di = vec2(0, 0);

            dr.x = -(2.0*((px - zx)*zx - (py - zy)*zy) + zy*zy + 1.0 - zx*zx);
            dr.y = -2.0*((py - zy - zy)*zx + (px - zx)*zy);

            di.x = 2.0*((py - zy - zy)*zx + (px - zx)*zy);
            di.y = -(2.0*((px - zx)*zx - (py - zy)*zy) + zy*zy + 1.0 - zx*zx);

            //heissan matrices
            let rxm = mat2(vec2(4.0*(px - 3.0*zx)*(px - 3.0*zx), -4.0*(px - 3.0*zx)*(py - 3.0*zy)),
              vec2(-4.0*(px - 3.0*zx)*(py - 3.0*zy), 4.0*(py - 3.0*zy)*(py - 3.0*zy)));

            let rym = mat2(vec2(4.0*(py - 3.0*zy)*(py - 3.0*zy), 4.0*(px - 3.0*zx)*(py - 3.0*zy)),
              vec2(4.0*(px - 3.0*zx)*(py - 3.0*zy), 4.0*(px - 3.0*zx)*(px - 3.0*zx)));

            let ixm = mat2(vec2(4.0*(py - 3.0*zy)*(py - 3.0*zy), 4.0*(px - 3.0*zx)*(py - 3.0*zy)),
              vec2(4.0*(px - 3.0*zx)*(py - 3.0*zy), 4.0*(px - 3.0*zx)*(px - 3.0*zx)));

            let iym = mat2(vec2(4.0*(px - 3.0*zx)*(px - 3.0*zx), -4.0*(px - 3.0*zx)*(py - 3.0*zy)),
              vec2(-4.0*(px - 3.0*zx)*(py - 3.0*zy), 4.0*(py - 3.0*zy)*(py - 3.0*zy)));

            let m = inverse(mat2(dr, di));

            let off = m.mulVec(a).negate();
            off.iadd(vec2(-off.y, off.x).imulScalar(SLIDERS[10]));

            dist += 2.0*length(off)/(0.2 + length(iym.mul(rxm).mulVec(off)));

            //dist += 0.12 / (0.1 + length(rym*off));

            //dist += (determinant(rxm) + determinant(rym) + determinant(ixm) + determinant(iym))*1000.0;
            //dist += determinant(rxm*rym*ixm*iym)*100000.0;
            //dist += (abs(off[0]) + abs(off[1]))*0.5;
            //dist += max(abs(off[0]), abs(off[1]));

            uv.iadd(off);
          }

          mstack.pop();
          vstack.pop();

          let d1 = length(uv.sub(vec2(-1.0, 0.0)));
          let d2 = length(uv.sub(vec2(1.0, 0.0)));
          let d3 = length(uv.sub(seed));

          //find closest root shade
          f = d1 < d2 ? 1.0 : 0.75;
          f = d3 < d2 && d3 < d1 ? 0.5 : f;

          let tfac = pow(1.0 - toff, 0.25);
          let dfract;
          dfract = tent(dist*0.004);
          f = sqrt(dfract)*0.5;

          return f;
        }

        tracePaths() {
          if (this.paths.length > 0) {
            animManager.stop("paths");
            this.paths.length = 0;
            return;
          }

          let totpoints = 1024*4;
          this.paths.length = 0;

          let dimen = Math.ceil(Math.sqrt(totpoints));
          let width = this.glSize[0], height = this.glSize[1];

          totpoints = dimen*dimen;

          let p = [0, 0];

          for (let i = 0; i < totpoints; i++) {
            let x = i%dimen, y = ~~(i/dimen);

            x += (util.random() - 0.5);
            y += (util.random() - 0.5);

            x = (x/dimen)*width;
            y = (y/dimen)*height;

            p[0] = x;
            p[1] = y;

            this.transform(p);

            //this.untransform(p);
            //console.log(p, x, y);

            let path = new Path(p[0], p[1]);
            this.paths.push(path);
          }

          let job = () => {
            let t = util.time_ms();
            while (util.time_ms() - t < 15) {
              for (let path of this.paths) {
                path.step(this);
              }
            }
          }

          animManager.stop("paths");
          animManager.run("paths", job, -1)
        }

        cpuRender() {
          console.log("trace paths!");

          if (this.image) {
            this.image = undefined;
            animManager.stop("render");
            return;
          }

          animManager.stop("render");

          let size = 700;

          this.image = new ImageData(size, size);
          let img = this.image.data;

          for (let i = 0; i < size*size*4; i += 4) {
            img[i] = img[i + 1] = img[i + 2] = 0;
            img[i + 3] = 255;
          }

          let width = this.glSize[0];
          let height = this.glSize[1];

          let i = 0;
          let outSimd = [0, 0];

          const doSimd = false;

          let job = () => {
            for (let i = 0; i < SLIDERS.length; i++) {
              wasmArgs.sliders[i] = SLIDERS[i];
            }

            let t = util.time_ms();
            while (util.time_ms() - t < 250) {
              let iend = Math.min(i + 256, size*size);

              if (i >= size*size) {
                animManager.stop("render");
                break;
              }

              for (; i < iend; i++) {
                let ix = i%size, iy = ~~(i/size);

                let iRes = vec2(width, height);
                let uv = vec2(ix, height - iy);

                if (wasm.ready && doSimd && i < iend-1) {
                  i++;

                  ix = i%size, iy = ~~(i/size);

                  let uv2 = vec2(ix, height - iy);
                  this.internalRunWasmSimd(outSimd, uv, uv2, iRes);

                  //i--;
                  for (let j=0; j<2; j++) {
                    let i2 = i - 1 + j;

                    let f = Math.floor(out[j]*3*255 + (Math.random() - 0.5));

                    img[i2*4] = img[i2*4 + 1] = img[i2*4 + 2] = f;
                  }

                  continue;
                }

                if (!wasm.ready) {
                  vstack.push();
                  mstack.push();
                }

                let f = this.internalRun(uv, iRes);

                if (!wasm.ready) {
                  vstack.pop();
                  mstack.pop();
                }

                f = Math.floor(f*3*255 + (Math.random() - 0.5));

                img[i*4] = img[i*4 + 1] = img[i*4 + 2] = f;
                //let idx = (iy*size + ix) * 4;
                //img[idx] = img[idx+1] = img[idx+2] = f;
              }
            }
          }

          animManager.run("render", job, -1);
        }

        checkPaths() {
          if (calcViewKey() != this._last_view_key) {
            this.clearPaths();
            this._last_view_key = calcViewKey();
          }
        }

        clearPaths() {
          this.paths = [];
        }

        reset() {
          this.image = undefined;
          animManager.stop("render");
          animManager.stop("paths");

          SLIDERS[4] = DEFAULT_SLIDERS[4];
          SLIDERS[5] = DEFAULT_SLIDERS[5];
          SLIDERS[6] = DEFAULT_SLIDERS[6];
          this.render.drawGen++;

          this.clearPaths();
        }

        on_keydown(e) {
          console.log(e.keyCode);

          switch (e.keyCode) {
            case 82: //rkey
              //for (let i=0; i<DEFAULT_SLIDERS.length; i++) {
              //SLIDERS[i] = DEFAULT_SLIDERS[i];
              this.undoPush();

              if (e.shiftKey) {
                for (let i = 0; i < DEFAULT_SLIDERS.length; i++) {
                  SLIDERS[i] = DEFAULT_SLIDERS[i];
                }
                this.render.drawGen++;
              } else {
                this.reset();
              }

              //}
              break;
            case 90: //zkey
              if (e.ctrlKey && !e.shiftKey) {
                this.undo();
              } else if (e.ctrlKey && e.shiftKey) {
                this.redo();
              }
              break;
            case 83: //skey
              this.save();
              break;
            case 84: //tkey
              config.SHOW_SLIDERS ^= true;
              break;
            case 75: //kkey
              this.cpuRender();
              break;
            case 68: //dkey
              this.tracePaths();
              break;
          }
          if (this.drawrect) {
            this.drawrect = undefined;
          }
        }

        draw() {
          this.sliders.visible = config.SHOW_SLIDERS;
          this.render.draw(this.gl);

          this.g.clearRect(0, 0, this.canvas2d.width, this.canvas2d.height);

          if (this.image) {
            this.g.putImageData(this.image, 0, 0);
          }

          for (let path of this.paths) {
            path.draw(this, this.g);
          }

          let scale = devicePixelRatio/this.getDPI();

          if (this.drawrect) {
            this.g.save();
            this.g.scale(scale, scale);

            this.g.beginPath();
            this.g.strokeStyle = "white";
            this.g.lineWidth = 1;

            let r = this.drawrect;
            let minx = Math.min(r[0][0], r[1][0]);
            let miny = Math.min(r[0][1], r[1][1]);
            let maxx = Math.max(r[0][0], r[1][0]);
            let maxy = Math.max(r[0][1], r[1][1]);
            let w = maxx - minx;
            let h = maxy - miny;

            //this.g.moveTo(r[0][0], r[0][1]);
            //this.g.lineTo(r[1][0], r[1][1]);
            this.g.rect(minx, miny, w, h);

            this.g.stroke();

            this.g.restore();
          }

          //this.g.save();
          //this.g.scale(scale, scale);

          this.sliders.draw(this.canvas2d, this.g);

          //this.g.restore();

          window.T += 0.0001;
          redraw_all();

          this.updateSize();
        }

        getDPI() {
          return config.DPI*devicePixelRatio;
        }

        updateSize() {
          let {canvas, canvas2d} = this;

          let dpi = this.getDPI();

          let w = ~~((window.innerWidth - 28)*dpi);
          let h = ~~((window.innerHeight - 28)*dpi);

          let key = "" + dpi + ":" + w + ":" + h;
          if (key === this._last_size_key) {
            return;
          }

          console.log("updating size");
          this._last_size_key = key;

          let w2d = ~~(window.innerWidth*devicePixelRatio - 28);
          let h2d = ~~(window.innerHeight*devicePixelRatio - 28);

          canvas.width = w;
          canvas.height = h;

          canvas2d.width = w2d;
          canvas2d.height = h2d;

          canvas.style["width"] = (canvas.width/dpi) + "px";
          canvas.style["height"] = (canvas.height/dpi) + "px";

          canvas2d.style["width"] = (canvas2d.width/devicePixelRatio) + "px";
          canvas2d.style["height"] = (canvas2d.height/devicePixelRatio) + "px";

          if (this.render) {
            this.render.drawGen++;
          }
        }
      }

      function start() {
        console.log("init!");

        let canvas = document.getElementById("canvas");
        let canvas2d = document.getElementById("canvas2d");
        let dpi = devicePixelRatio;

        canvas.width = ~~(window.innerWidth*dpi - 28);
        canvas.height = ~~(window.innerHeight*dpi - 28);
        canvas2d.width = canvas.width;
        canvas2d.height = canvas.height;

        canvas.style["width"] = canvas2d.style["width"] = (canvas.width/dpi) + "px";
        canvas.style["height"] = canvas2d.style["height"] = (canvas.height/dpi) + "px";
        let g = canvas2d.getContext("2d");

        let gl = webgl.init_webgl(canvas, {}, true);

        loadShaders(gl);

        gl.clearColor(0.2, 0.4, 0.9, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        window._appstate = new AppState(gl, canvas, g, canvas2d);
        _appstate.glSize = [canvas.width, canvas.height];

        let animreq = undefined;

        function do_draw() {
          animreq = undefined;
          _appstate.draw();
        }

        window.redraw_all = function () {
          if (animreq == undefined) {
            animreq = requestAnimationFrame(do_draw);
          }
        }

        _appstate.load();

        redraw_all();
      }

      start();
    });

  </script>
  <style>
      #canvas {
          position: absolute;
          z-index: -3;
      }

      #canvas2d {
          position: absolute;
          z-index: -2;
      }
  </style>
</head>
<body>
<canvas id="canvas">
</canvas>
<canvas id="canvas2d">
</canvas>
</body>
</html>