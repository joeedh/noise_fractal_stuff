<!DOCTYPE html>
<html>
<head><title>WebGL Noise Tester</title>
<script type="application/javascript" src="js/require.js">
</script>
<script type="application/x-fragment-shader" id="fragment">
uniform vec2 iRes;
uniform float aspect;
uniform float SLIDERS[6];
uniform float T;

#define PI 3.141592654

float tent(float f) {
  return 1.0 - abs(fract(f)-0.5)*2.0;
}
float cos1(float f) {
  return cos(f*3.141592654)*0.5 + 0.5;
}
float sin1(float f) {
  return sin(f*3.141592654)*0.5 + 0.5;
}

float tent2(float f) {
  return tent(f+0.5);
}

#if 1
struct Float2 {
    float exp, mant, sign;
};

int ilog(int f) {
  int fret = f - 1;

  f -= 1;
  int f2 = f*f, f3 = f2*f, f4=f3*f, f5=f4*f, f6=f5*f, f7=f6*f;
  
  fret += -f2/2 + f3/3 - f4/4 + f5/5 - f6/6 + f7/7;
  
  return fret;
}

int ilog2(int f) {
  return (ilog(f)*1448) >> 10;
}

int ifloor(int f) {
  return f;
}

Float2 normFloat2(Float2 a) {
    //int exp = ilog2(a.mant);
    //float  exp = floor(log(a.mant) / log(2.0));
    float exp = floor(log2(a.mant));
    
    a.mant = a.mant * pow(2.0, -exp);
    a.exp += exp;
    
    return a;
}

Float2 f32toFloat2(float f) {
    Float2 f2;

    if (f == 0.0) {
        return f2;
    }
    
    f2.sign = f < 0.0 ? -1.0 : 1.0;
    f = abs(f);
    
    f2.exp = floor(log(f) / log(2.0));
    
    f2.mant = f*pow(2.0, -f2.exp);
    
    return normFloat2(f2);
}

float Float2tof32(Float2 f) {
    f = normFloat2(f);
    return pow(2.0, f.exp)*f.mant*f.sign;
}

Float2 mulFloat2(Float2 a, Float2 b) {
    Float2 r;
    
    r.sign = a.sign * b.sign;
    r.mant = a.mant * b.mant;
    r.exp = a.exp + b.exp;
    
    return normFloat2(r);
}

Float2 divFloat2(Float2 a, Float2 b) {
    Float2 r;
    
    r.sign = a.sign * b.sign;
    r.mant = a.mant / b.mant;
    r.exp = a.exp - b.exp;
    
    return normFloat2(r);
}

Float2 addFloat2(Float2 a, Float2 b) {
    if (a.exp > b.exp) {
        Float2 t = a;
        a = b;
        b = t;
    }
    
    a.mant *= pow(2.0, a.exp - b.exp);
    a.exp = b.exp;
    
    if (a.sign != b.sign) {
        a.mant = a.mant - b.mant;
    } else {
        a.mant += b.mant;
    }
    
    if (a.mant < 0.0) {
        a.mant = -a.mant;
        a.sign = -a.sign;
    }
    
    return normFloat2(a);
}

Float2 subFloat2(Float2 a, Float2 b) {
    b.sign = -b.sign;
    
    return addFloat2(a, b);
}

bool overLimit(Float2 x, Float2 y) {
    return x.exp > 15.0 || y.exp > 15.0;
}
#elif 1
struct Float2 {
  float f;
};

Float2 normFloat2(Float2 a) {
    return a;
}

Float2 f32toFloat2(float f) {
  Float2 r;
  
  r.f = f;
  
  return r;
}

float Float2tof32(Float2 f) {
  return f.f;
}

Float2 mulFloat2(Float2 a, Float2 b) {
  b.f *= a.f;
  return b;
}

Float2 divFloat2(Float2 a, Float2 b) {
  b.f = a.f / b.f;
  return b;
}

Float2 addFloat2(Float2 a, Float2 b) {
  b.f += a.f;
  return b;
}

Float2 subFloat2(Float2 a, Float2 b) {
  Float2 r;
  
  r.f = a.f - b.f;
  
  return r;
}

bool overLimit(Float2 x, Float2 y) {
  //return x.f > 1000.0 || y.f > 1000.0;
  return x.f*x.f + y.f*y.f > 1000.0;
}

#else

struct Float2 {
    float a, b, sign;
};

Float2 normFloat2(Float2 a) {
    return a;
}

Float2 f32toFloat2(float f) {
    Float2 r;
    
    r.sign = f < 0.0 ? -1.0 : 1.0;
    //f = abs(f);
    
    r.a = f*0.5;
    r.b = f*0.5;
    
    return r;
}

float Float2tof32(Float2 f) {
    return f.sign*(f.a + f.b);
}

Float2 mulFloat2(Float2 a, Float2 b) {
    Float2 r;
    
    //r.sign = a.sign * b.sign;
    
    r.a = a.a*b.a + a.a*b.b;
    r.b = a.b*b.a + a.b*b.b;
    
    return r;
}

Float2 addFloat2(Float2 a, Float2 b) {
    Float2 r;
    
    r.a = a.a + b.a;
    r.b = a.b + b.b;
    
    return r;
}

Float2 subFloat2(Float2 a, Float2 b) {
    b.a = -b.a;
    b.b = -b.b;
    
    return addFloat2(a, b);
}

bool overLimit(Float2 x, Float2 y) {
    return x.a > 1000.0 || x.b > 1000.0 || y.a > 1000.0 || y.b > 1000.0;
}
#endif
//#define cos(x) (tent((x)/(2.0*PI))*2.0-1.0)
//#define sin(x) (tent(0.5+(x)/(2.0*PI))*2.0-1.0)

float pattern(float ix, float iy) {
  vec2 uv = vec2(ix, iy) / iRes;
  uv -= 0.5;
  
  uv[0] *= iRes.x / iRes.y;

  int i;
  
  //float scale = pow(max(SLIDERS[1], 0.000001), 2.0);
  float scale = SLIDERS[1]*SLIDERS[1];
  
  Float2 fuvx = f32toFloat2(uv.x);
  Float2 fuvy = f32toFloat2(uv.y);
  
  Float2 fstartuvx = f32toFloat2(uv.x*6.0);
  Float2 fstartuvy = f32toFloat2(uv.y*6.0);
  
  Float2 fscale = f32toFloat2(scale);
  
  fscale = addFloat2(f32toFloat2(1.0), fscale);
  fscale = mulFloat2(mulFloat2(fscale, fscale), fscale);
  fscale = divFloat2(f32toFloat2(1.0), fscale);
  
  //vec2 startuv = uv*6.0;  
  //uv = startuv*scale;
  
  fuvx = addFloat2(mulFloat2(fstartuvx, fscale), f32toFloat2(SLIDERS[2]));
  fuvy = addFloat2(mulFloat2(fstartuvy, fscale), f32toFloat2(SLIDERS[3]));
  
  uv += vec2(SLIDERS[2], SLIDERS[3]);
  vec2 lastp = uv;
  float x=0., y = 0.;
  float sum = 0.0;
  
  #define STEPS 128
  //float xc = 0.0, yc = 0.0; //for kahn summation
  
  Float2 f2uv_x = fuvx; //addFloat2(mulFloat2(fstartuvx, fscale), f32toFloat2(SLIDERS[2]));
  Float2 f2uv_y = fuvy; //addFloat2(mulFloat2(fstartuvy, fscale), f32toFloat2(SLIDERS[3]));
  
  Float2 f2x = f2uv_x, f2y = f2uv_y;
  Float2 const2 = f32toFloat2(2.0);
  
  /*
  if (uv.y < 0.5)
    return Float2tof32(addFloat2(f2uv_x, f2uv_y));
  else
    return uv.x + uv.y;
   //*/
  for (int i=0; i<STEPS; i++) {
    Float2 f2x2 = addFloat2(subFloat2(mulFloat2(f2x, f2x), mulFloat2(f2y, f2y)), f2uv_x);
    Float2 f2y2 = addFloat2(mulFloat2(const2, mulFloat2(f2x, f2y)), f2uv_y);
    
    f2x = f2x2;
    f2y = f2y2;
    
    //float x2 = x*x - y*y;
    //float y2 = 2.0*x*y;
    
    /*
    float xy = uv.x - xc;
    float xt = x2 + xy;
    xc = (xt - x2) - xy;
    x2 = xt;
    
    float yy = uv.y - yc;
    float yt = y2 + yy;
    yc = (yt - y2) - yy;
    y2 = yt;
    //*/
    //x2 += uv.x;
    //y2 += uv.y;
    
    //x = x2;
    //y = y2;
    
    //sum += float(y >= 0.0);
    
#define LIMIT 100000.0
    if (overLimit(f2x, f2y)) {
    //if (x*x + y*y > LIMIT) {
        //x = Float2tof32(f2x2);
        return float(i)/float(STEPS);
#if 0
        vec2 p = vec2(x, y);
        
        float f = float(i) / float(STEPS);
        float d = length(p - lastp)/LIMIT;
        float l = 12.0;
        
        float d2 = 1.0 - sqrt(d)*d;
        d2 = clamp(d2, 0.0, 1.0);
        d2 = pow(d2, 9.0);
        //return d2;
        
        //d = pow(d, 0.225);
        float l2 = 12.5;
        d = log(1.0 + d*l2) / log(l2);
        d = log(1.0 + d*l2) / log(l2);

        float e = atan(y, x)/PI/2.0;
        
        d *= 0.95;
        d2 = pow(1.0 - d, 4.0);
        
        e = fract(e) + (pow(fract(e*2.0), fract(e) > 0.5 ? 1.25 : 0.8) - fract(e))*d2;
        return f*f*2.0*tent(e);
        //return tent(d*4.0+0.5);
        float tu = fract(e), tv = fract(d);
        
        return max(tent(e), tent(tv+0.5));
#endif
    }
    
    lastp = vec2(x, y);
  }
  
  return float(i) / float(STEPS);
}

vec4 shader(float ix, float iy) {
  float f = pattern(ix, iy);
  
  float freq = 0.5;
  float r = cos1((f+SLIDERS[5]*10.0)*freq*3.0+0.3);//+T*100.0);
  float g = cos1((f+SLIDERS[5]*10.0)*freq*2.0+0.5);//+T*100.0);
  float b = cos1((f+SLIDERS[5]*10.0)*freq*1.0+0.3);//+T*100.0);
  
  //r=g=b=f;
  if (iy/iRes.y < 0.3)
    r=g=b=f;
  
  return vec4(r, g, b, 1.0);
}
</script>
<script type="application/javascript">
'use strict';

require.config({
  baseUrl : "./js/"
});
var SLIDER_NAMES = [
  "seed", "detail", "filter", "gain", "color", "mix"
];

var SLIDERS;

window.T = 0;

SLIDERS=[1,0.004285714285714962,0.055714285714286,0.025285714285714,1.41857142857143,1.6779571428571414];
SLIDERS=[1,0.005071428571428951,-0.7641428571428551,0.10107142857142801,1.41857142857143,1.6779571428571414];
SLIDERS=[1.2371428571428567,0.6428571428572507,-0.7641428571428551,0.10107142857142801,1.41857142857143,1.6779571428571414];
SLIDERS=[1.2371428571428567,0.011428571428679694,-0.7641428571428551,0.10107142857142801,1.41857142857143,1.6779571428571414];
SLIDERS=[1.2371428571428567,0.0010000000001082548,-0.7641428571428551,0.10107142857142801,1.41857142857143,1.6779571428571414];

//SLIDERS=[1.2371428571428567,0.6838571428572507,-0.7641428571428551,0.10107142857142801,1.41857142857143,1.6779571428571414];

SLIDERS[1] = 10.0;

var continued_fract_tmp = new Array(1024);
function cfract_intern(n, max_steps) {
  var floor = Math.floor;
  max_steps = max_steps == undefined ? 1024 : max_steps;
  
  var list = continued_fract_tmp;
  
  for (var i=0; i<max_steps; i++) {
    var f = floor(n)
    list[i] = f;
    
    n -= f;
    
    if (f == 0) 
      break;
      
    n = 1.0 / n
  }
  
  var len = i;
  
  var f = 1;
  for (var i=len-1; i >= 0; i--) {
    f = list[i] + 1/f;
  }
  
  return f;
}

function cfract(f, max) {
    let sign = Math.sign(f);
    
    f = Math.abs(f);
    
    if (f < 1.0) {
        f = cfract_intern(f+1.0, max) - 1.0;
    } else {
        f = cfract_intern(f, max);
    }
    
    if (max == 1) {
        f -= 1;
    }
    
    return f*sign;
}

require(["util", "webgl", "sliders"], function(util, webgl, sliders) {
  var Render = util.Class([
    function constructor() {
      this.buffer = new webgl.RenderBuffer();
      this.regen = 1;
    },
    
    function regen_buffers(gl) {
      this.regen = 0;
      var mesh = [
        0, 0,   0, 1,   1, 1,
        0, 0,   1, 1,   1, 0
      ];
      
      var vbuf = this.vbuf = this.buffer.get(gl, "vertex")
      
      gl.bindBuffer(gl.ARRAY_BUFFER, vbuf);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(mesh), gl.STATIC_DRAW);
   },
    
    function draw(gl) {
      if (this.regen) {
        this.regen_buffers(gl);
        this.compile_shader(gl);
      }
      
      var vbuf = this.vbuf;
      var shader = this.shader;
      
      gl.enableVertexAttribArray(0);
      gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
      
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.DITHER);
      
      gl.viewport(0, 0, canvas.width, canvas.height);
      
      shader.bind(gl, {
        iRes    : [canvas.width, canvas.height],
        aspect  : canvas.height / canvas.width
      });
      
      gl.uniform1f(shader.uniformloc("T"), window.T);
      
      let SLIDERS2 = SLIDERS.clone();
      //SLIDERS2[0] = cfract(SLIDERS2[0], Math.max(Math.ceil(SLIDERS2[1]*10.0), 1));
      
      for (var i=0; i<SLIDERS2.length; i++) {
        gl.uniform1f(shader.uniformloc("SLIDERS["+i+"]"), SLIDERS2[i]);
      }
      
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    },
    
    function compile_shader(gl) {
      var code = document.getElementById("fragment").text;
      
      var vshader = [
        "#version 300 es",
        "precision highp float;",

        "#define varying out",
        "#define attribute in",
        
        "attribute vec2 co;",
        "varying vec2 vCo;",
        
        "void main() {",
        "  gl_Position = vec4((co-0.5)*2.0, 0.0, 1.0);",
        "  vCo = co;",
        "}"
      ].join("\n");
      
      var fshader = [
        "#version 300 es",
        "#define varying in",
        "precision highp float;",
        code,
        "out vec4 fragColor;",
        "varying vec2 vCo;",
        "void main() {",
        "  vec2 p = vCo * iRes.xy;",
        "  fragColor = shader(p[0], p[1]);",
        "}"
      ].join("\n");
      
      var shader = new webgl.ShaderProgram(gl, vshader, fshader, ["co"]);
      this.shader = shader;
    }
  ]);

  var AppState = util.Class([
    function constructor(gl, canvas, g, canvas2d) {
      this.gl = gl; //3d api
      this.g = g;   //2d api
      
      this.canvas2d = canvas2d;
      this.canvas = canvas;
      this.render = new Render();
      
      this.sliders = new sliders.SliderManager(50, 50, 25, 
                                               window.innerHeight-150, SLIDERS, SLIDER_NAMES);
      this.sliders.bind_events();
    },
    
    function draw() {
      this.render.draw(this.gl);
      
      this.g.clearRect(0, 0, this.canvas2d.width, this.canvas2d.height);
      this.sliders.draw(this.canvas2d, this.g);
      
      window.T += 0.0001;
      redraw_all();
    }
  ]);
  
  function start() {
    console.log("init!");
    
    var canvas = document.getElementById("canvas");
    var canvas2d = document.getElementById("canvas2d");
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    canvas2d.width = window.innerWidth;
    canvas2d.height = window.innerHeight;
    var g = canvas2d.getContext("2d");
    
    var gl = webgl.init_webgl(canvas, {}, true);
    gl.clearColor(0.2, 0.4, 0.9, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    window._appstate = new AppState(gl, canvas, g, canvas2d);
    
    var animreq = undefined;
    function do_draw() {
      animreq = undefined;
      _appstate.draw();
    }
    
    window.redraw_all = function() {
      if (animreq == undefined) {
        animreq = requestAnimationFrame(do_draw);
      }
    }
    
    redraw_all();
  }
  
  start();
});

</script>
<style>
#canvas {
  position : absolute;
  z-index  : 0;
}

#canvas2d {
  position : absolute;
  z-index  : 1;
}
</style>
</head>
<body>
<canvas id="canvas">
</canvas>
<canvas id="canvas2d">
</canvas>
</body>
</html>